# -*- coding: utf-8 -*-
"""
ALADDIN Security System - MalwareDetectionAgent
Агент обнаружения вредоносного ПО - КРИТИЧНО

Автор: ALADDIN Security Team
Версия: 1.0
Дата: 2025-09-12
"""

import datetime
import hashlib
import json
import os
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional


class MalwareType(Enum):
    """Типы вредоносного ПО"""

    VIRUS = "virus"
    TROJAN = "trojan"
    RANSOMWARE = "ransomware"
    SPYWARE = "spyware"
    ADWARE = "adware"
    ROOTKIT = "rootkit"
    WORM = "worm"
    BACKDOOR = "backdoor"
    KEYLOGGER = "keylogger"
    BOTNET = "botnet"
    UNKNOWN = "unknown"


class ThreatLevel(Enum):
    """Уровень угрозы"""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class DetectionMethod(Enum):
    """Метод обнаружения"""

    SIGNATURE = "signature"
    HEURISTIC = "heuristic"
    BEHAVIORAL = "behavioral"
    MACHINE_LEARNING = "machine_learning"
    SANDBOX = "sandbox"
    STATIC_ANALYSIS = "static_analysis"
    DYNAMIC_ANALYSIS = "dynamic_analysis"


@dataclass
class MalwareSignature:
    """Подпись вредоносного ПО"""

    signature_id: str
    name: str
    malware_type: MalwareType
    threat_level: ThreatLevel
    pattern: str  # Регулярное выражение или хеш
    description: str
    detection_method: DetectionMethod
    created_at: str = field(
        default_factory=lambda: datetime.datetime.now().isoformat()
    )
    updated_at: str = field(
        default_factory=lambda: datetime.datetime.now().isoformat()
    )
    is_active: bool = True

    def to_dict(self) -> Dict[str, Any]:
        """Преобразует подпись в словарь для сериализации."""
        return {
            "signature_id": self.signature_id,
            "name": self.name,
            "malware_type": self.malware_type.value,
            "threat_level": self.threat_level.value,
            "pattern": self.pattern,
            "description": self.description,
            "detection_method": self.detection_method.value,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
            "is_active": self.is_active,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MalwareSignature":
        """Создает подпись из словаря."""
        return cls(
            signature_id=data["signature_id"],
            name=data["name"],
            malware_type=MalwareType(data["malware_type"]),
            threat_level=ThreatLevel(data["threat_level"]),
            pattern=data["pattern"],
            description=data["description"],
            detection_method=DetectionMethod(data["detection_method"]),
            created_at=data.get(
                "created_at", datetime.datetime.now().isoformat()
            ),
            updated_at=data.get(
                "updated_at", datetime.datetime.now().isoformat()
            ),
            is_active=data.get("is_active", True),
        )

    def __str__(self) -> str:
        """Возвращает строковое представление подписи."""
        return f"MalwareSignature(id={self.signature_id}, name={self.name}, type={self.malware_type.value})"

    def __repr__(self) -> str:
        """Возвращает детальное строковое представление подписи."""
        return (f"MalwareSignature(signature_id='{self.signature_id}', "
                f"name='{self.name}', malware_type={self.malware_type}, "
                f"threat_level={self.threat_level}, pattern='{self.pattern}', "
                f"detection_method={self.detection_method}, is_active={self.is_active})")


@dataclass
class MalwareDetection:
    """Результат обнаружения вредоносного ПО"""

    detection_id: str
    file_path: str
    file_hash: str
    file_size: int
    malware_type: MalwareType
    threat_level: ThreatLevel
    confidence: float  # 0.0 - 1.0
    detection_method: DetectionMethod
    signature_matched: Optional[str] = None
    description: str = ""
    detected_at: str = field(
        default_factory=lambda: datetime.datetime.now().isoformat()
    )
    quarantine_path: Optional[str] = None
    is_false_positive: bool = False
    additional_info: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Преобразует обнаружение в словарь для сериализации."""
        return {
            "detection_id": self.detection_id,
            "file_path": self.file_path,
            "file_hash": self.file_hash,
            "file_size": self.file_size,
            "malware_type": self.malware_type.value,
            "threat_level": self.threat_level.value,
            "confidence": self.confidence,
            "detection_method": self.detection_method.value,
            "signature_matched": self.signature_matched,
            "description": self.description,
            "detected_at": self.detected_at,
            "quarantine_path": self.quarantine_path,
            "is_false_positive": self.is_false_positive,
            "additional_info": self.additional_info,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MalwareDetection":
        """Создает обнаружение из словаря."""
        return cls(
            detection_id=data["detection_id"],
            file_path=data["file_path"],
            file_hash=data["file_hash"],
            file_size=data["file_size"],
            malware_type=MalwareType(data["malware_type"]),
            threat_level=ThreatLevel(data["threat_level"]),
            confidence=data["confidence"],
            detection_method=DetectionMethod(data["detection_method"]),
            signature_matched=data.get("signature_matched"),
            description=data.get("description", ""),
            detected_at=data.get(
                "detected_at", datetime.datetime.now().isoformat()
            ),
            quarantine_path=data.get("quarantine_path"),
            is_false_positive=data.get("is_false_positive", False),
            additional_info=data.get("additional_info", {}),
        )

    def __str__(self) -> str:
        """Возвращает строковое представление обнаружения."""
        return f"MalwareDetection(id={self.detection_id}, file={self.file_path}, type={self.malware_type.value}, confidence={self.confidence:.2f})"

    def __repr__(self) -> str:
        """Возвращает детальное строковое представление обнаружения."""
        return (f"MalwareDetection(detection_id='{self.detection_id}', "
                f"file_path='{self.file_path}', file_hash='{self.file_hash}', "
                f"malware_type={self.malware_type}, threat_level={self.threat_level}, "
                f"confidence={self.confidence}, detection_method={self.detection_method})")


@dataclass
class ScanResult:
    """Результат сканирования"""

    scan_id: str
    scan_type: str  # "full", "quick", "custom", "real_time"
    start_time: str
    end_time: str
    files_scanned: int
    threats_found: int
    files_quarantined: int
    scan_duration: float  # в секундах
    detections: List[MalwareDetection] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Преобразует результат сканирования в словарь для сериализации."""
        return {
            "scan_id": self.scan_id,
            "scan_type": self.scan_type,
            "start_time": self.start_time,
            "end_time": self.end_time,
            "files_scanned": self.files_scanned,
            "threats_found": self.threats_found,
            "files_quarantined": self.files_quarantined,
            "scan_duration": self.scan_duration,
            "detections": [d.to_dict() for d in self.detections],
            "errors": self.errors,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ScanResult":
        """Создает результат сканирования из словаря."""
        return cls(
            scan_id=data["scan_id"],
            scan_type=data["scan_type"],
            start_time=data["start_time"],
            end_time=data["end_time"],
            files_scanned=data["files_scanned"],
            threats_found=data["threats_found"],
            files_quarantined=data["files_quarantined"],
            scan_duration=data["scan_duration"],
            detections=[
                MalwareDetection.from_dict(d)
                for d in data.get("detections", [])
            ],
            errors=data.get("errors", []),
        )

    def __str__(self) -> str:
        """Возвращает строковое представление результата сканирования."""
        return f"ScanResult(id={self.scan_id}, files={self.files_scanned}, threats={self.threats_found}, duration={self.scan_duration:.2f}s)"

    def __repr__(self) -> str:
        """Возвращает детальное строковое представление результата сканирования."""
        return (f"ScanResult(scan_id='{self.scan_id}', scan_type='{self.scan_type}', "
                f"files_scanned={self.files_scanned}, threats_found={self.threats_found}, "
                f"files_quarantined={self.files_quarantined}, scan_duration={self.scan_duration})")


class MalwareDetectionAgent:
    """
    Агент обнаружения вредоносного ПО с использованием множественных методов.
    """

    def __init__(self, name: str = "MalwareDetectionAgent"):
        """Инициализирует агент обнаружения вредоносного ПО.
        
        Args:
            name: Имя агента для идентификации
        """
        self.name = name
        self.signatures: List[MalwareSignature] = []
        self.detections: List[MalwareDetection] = []
        self.scan_results: List[ScanResult] = []
        self.quarantine_dir = "/tmp/aladdin_quarantine"
        self.scan_exclusions = [
            "/System/",
            "/Library/",
            "/usr/",
            "/bin/",
            "/sbin/",
            ".git/",
            "__pycache__/",
            ".pyc",
            ".pyo",
        ]

        # Создаем карантинную папку
        os.makedirs(self.quarantine_dir, exist_ok=True)

        # Загружаем базовые сигнатуры
        self._load_default_signatures()

    def _load_default_signatures(self):
        """Загружает базовые сигнатуры вредоносного ПО"""
        default_signatures = [
            MalwareSignature(
                signature_id="sig_001",
                name="Generic Trojan",
                malware_type=MalwareType.TROJAN,
                threat_level=ThreatLevel.HIGH,
                pattern=r"trojan|backdoor|keylogger",
                description="Обнаружение троянских программ",
                detection_method=DetectionMethod.SIGNATURE,
            ),
            MalwareSignature(
                signature_id="sig_002",
                name="Ransomware Pattern",
                malware_type=MalwareType.RANSOMWARE,
                threat_level=ThreatLevel.CRITICAL,
                pattern=r"encrypt.*files|ransom|decrypt.*key",
                description="Обнаружение ransomware",
                detection_method=DetectionMethod.HEURISTIC,
            ),
            MalwareSignature(
                signature_id="sig_003",
                name="Suspicious File Extensions",
                malware_type=MalwareType.UNKNOWN,
                threat_level=ThreatLevel.MEDIUM,
                pattern=r"\.(exe|scr|bat|cmd|com|pif)$",
                description="Подозрительные расширения файлов",
                detection_method=DetectionMethod.STATIC_ANALYSIS,
            ),
        ]

        self.signatures.extend(default_signatures)
        print(f"Загружено {len(default_signatures)} базовых сигнатур")

    def add_signature(self, signature: MalwareSignature):
        """Добавляет новую сигнатуру"""
        self.signatures.append(signature)
        print(f"Добавлена сигнатура: {signature.name}")

    def scan_file(self, file_path: str) -> Optional[MalwareDetection]:
        """Сканирует один файл на наличие вредоносного ПО
        
        Args:
            file_path: Путь к файлу для сканирования
            
        Returns:
            MalwareDetection или None если угроз не найдено
        """
        if not file_path or not isinstance(file_path, str):
            print(f"Некорректный путь к файлу: {file_path}")
            return None
            
        if not os.path.exists(file_path):
            print(f"Файл не существует: {file_path}")
            return None

        try:
            # Получаем информацию о файле
            file_size = os.path.getsize(file_path)
            file_hash = self._calculate_file_hash(file_path)

            # Проверяем исключения
            if self._is_excluded_file(file_path):
                return None

            # Сканируем по сигнатурам
            detection = self._scan_by_signatures(
                file_path, file_hash, file_size
            )
            if detection:
                return detection

            # Эвристический анализ
            detection = self._heuristic_analysis(
                file_path, file_hash, file_size
            )
            if detection:
                return detection

            # Поведенческий анализ
            detection = self._behavioral_analysis(
                file_path, file_hash, file_size
            )
            if detection:
                return detection

        except Exception as e:
            print(f"Ошибка при сканировании файла {file_path}: {e}")

        return None

    def _calculate_file_hash(self, file_path: str) -> str:
        """Вычисляет хеш файла"""
        hash_md5 = hashlib.md5()
        try:
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except Exception as e:
            print(f"Ошибка: {e}")
            return ""

    def _is_excluded_file(self, file_path: str) -> bool:
        """Проверяет, исключен ли файл из сканирования"""
        for exclusion in self.scan_exclusions:
            if exclusion in file_path:
                return True
        return False

    def _scan_by_signatures(
        self, file_path: str, file_hash: str, file_size: int
    ) -> Optional[MalwareDetection]:
        """Сканирование по сигнатурам"""
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read(1024 * 1024)  # Читаем первые 1MB

            for signature in self.signatures:
                if not signature.is_active:
                    continue

                if signature.detection_method == DetectionMethod.SIGNATURE:
                    if re.search(signature.pattern, content, re.IGNORECASE):
                        return MalwareDetection(
                            detection_id=f"det_{datetime.datetime.now().timestamp()}",
                            file_path=file_path,
                            file_hash=file_hash,
                            file_size=file_size,
                            malware_type=signature.malware_type,
                            threat_level=signature.threat_level,
                            confidence=0.9,
                            detection_method=signature.detection_method,
                            signature_matched=signature.signature_id,
                            description=signature.description,
                        )
        except Exception as e:
            print(f"Ошибка: {e}")
            pass
        return None

    def _heuristic_analysis(
        self, file_path: str, file_hash: str, file_size: int
    ) -> Optional[MalwareDetection]:
        """Эвристический анализ файла"""
        suspicious_indicators = 0
        confidence = 0.0

        try:
            # Проверяем расширение файла
            file_ext = os.path.splitext(file_path)[1].lower()
            suspicious_extensions = [
                ".exe",
                ".scr",
                ".bat",
                ".cmd",
                ".com",
                ".pif",
                ".vbs",
                ".js",
            ]
            if file_ext in suspicious_extensions:
                suspicious_indicators += 1
                confidence += 0.3

            # Проверяем размер файла (очень маленькие или очень большие файлы)
            if (
                file_size < 1024 or file_size > 100 * 1024 * 1024
            ):  # < 1KB или > 100MB
                suspicious_indicators += 1
                confidence += 0.2

            # Проверяем имя файла
            filename = os.path.basename(file_path).lower()
            suspicious_names = [
                "virus",
                "trojan",
                "malware",
                "backdoor",
                "keylogger",
            ]
            for name in suspicious_names:
                if name in filename:
                    suspicious_indicators += 1
                    confidence += 0.4
                    break

            # Если достаточно подозрительных индикаторов
            if suspicious_indicators >= 2 and confidence >= 0.5:
                return MalwareDetection(
                    detection_id=f"det_{datetime.datetime.now().timestamp()}",
                    file_path=file_path,
                    file_hash=file_hash,
                    file_size=file_size,
                    malware_type=MalwareType.UNKNOWN,
                    threat_level=ThreatLevel.MEDIUM,
                    confidence=min(confidence, 0.8),
                    detection_method=DetectionMethod.HEURISTIC,
                    description="Обнаружено эвристическим анализом",
                )
        except Exception as e:
            print(f"Ошибка: {e}")
            pass
        return None

    def _behavioral_analysis(
        self, file_path: str, file_hash: str, file_size: int
    ) -> Optional[MalwareDetection]:
        """Поведенческий анализ файла"""
        try:
            # Простая проверка на подозрительные паттерны в имени и пути
            file_path_lower = file_path.lower()
            behavioral_patterns = [
                r"temp.*\.exe$",
                r"[0-9a-f]{8,}\.exe$",  # Случайные имена
                r"system.*\.tmp$",
                r"update.*\.exe$",
            ]

            for pattern in behavioral_patterns:
                if re.search(pattern, file_path_lower):
                    return MalwareDetection(
                        detection_id=f"det_{datetime.datetime.now().timestamp()}",
                        file_path=file_path,
                        file_hash=file_hash,
                        file_size=file_size,
                        malware_type=MalwareType.UNKNOWN,
                        threat_level=ThreatLevel.LOW,
                        confidence=0.6,
                        detection_method=DetectionMethod.BEHAVIORAL,
                        description="Подозрительное поведение файла",
                    )
        except Exception as e:
            print(f"Ошибка: {e}")
            pass
        return None

    def scan_directory(
        self, directory: str, scan_type: str = "full"
    ) -> ScanResult:
        """Сканирует директорию на наличие вредоносного ПО"""
        scan_id = f"scan_{datetime.datetime.now().timestamp()}"
        start_time = datetime.datetime.now().isoformat()
        files_scanned = 0
        threats_found = 0
        files_quarantined = 0
        detections = []
        errors = []

        print(f"Начинаем сканирование: {directory}")

        try:
            for root, dirs, files in os.walk(directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    files_scanned += 1

                    detection = self.scan_file(file_path)
                    if detection:
                        detections.append(detection)
                        threats_found += 1

                        # Карантин для критических угроз
                        if detection.threat_level in [
                            ThreatLevel.HIGH,
                            ThreatLevel.CRITICAL,
                        ]:
                            quarantine_path = self._quarantine_file(file_path)
                            if quarantine_path:
                                detection.quarantine_path = quarantine_path
                                files_quarantined += 1
                                print(f"Файл помещен в карантин: {file_path}")

                        print(
                            f"Обнаружена угроза: {file_path} - {detection.malware_type.value}"
                        )

        except Exception as e:
            error_msg = f"Ошибка при сканировании {directory}: {e}"
            errors.append(error_msg)
            print(error_msg)

        end_time = datetime.datetime.now().isoformat()
        scan_duration = (
            datetime.datetime.fromisoformat(end_time)
            - datetime.datetime.fromisoformat(start_time)
        ).total_seconds()

        result = ScanResult(
            scan_id=scan_id,
            scan_type=scan_type,
            start_time=start_time,
            end_time=end_time,
            files_scanned=files_scanned,
            threats_found=threats_found,
            files_quarantined=files_quarantined,
            scan_duration=scan_duration,
            detections=detections,
            errors=errors,
        )

        self.scan_results.append(result)
        self.detections.extend(detections)

        print(
            f"Сканирование завершено: {files_scanned} файлов, {threats_found} угроз"
        )
        return result

    def _quarantine_file(self, file_path: str) -> Optional[str]:
        """Помещает файл в карантин"""
        try:
            filename = os.path.basename(file_path)
            quarantine_path = os.path.join(self.quarantine_dir, filename)

            # Если файл с таким именем уже существует, добавляем timestamp
            if os.path.exists(quarantine_path):
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                quarantine_path = os.path.join(
                    self.quarantine_dir, f"{name}_{timestamp}{ext}"
                )

            # Копируем файл в карантин
            import shutil

            shutil.copy2(file_path, quarantine_path)

            # Удаляем оригинальный файл
            os.remove(file_path)

            return quarantine_path
        except Exception as e:
            print(f"Ошибка при помещении в карантин {file_path}: {e}")
            return None

    def get_detection_statistics(self) -> Dict[str, Any]:
        """Возвращает статистику обнаружений"""
        if not self.detections:
            return {"total_detections": 0}

        stats = {
            "total_detections": len(self.detections),
            "by_type": {},
            "by_threat_level": {},
            "by_method": {},
            "false_positives": sum(
                1 for d in self.detections if d.is_false_positive
            ),
            "quarantined": sum(
                1 for d in self.detections if d.quarantine_path
            ),
        }

        for detection in self.detections:
            # По типу
            malware_type = detection.malware_type.value
            stats["by_type"][malware_type] = (
                stats["by_type"].get(malware_type, 0) + 1
            )

            # По уровню угрозы
            threat_level = detection.threat_level.value
            stats["by_threat_level"][threat_level] = (
                stats["by_threat_level"].get(threat_level, 0) + 1
            )

            # По методу обнаружения
            method = detection.detection_method.value
            stats["by_method"][method] = stats["by_method"].get(method, 0) + 1

        return stats

    def update_signature(self, signature_id: str, updates: Dict[str, Any]):
        """Обновляет сигнатуру"""
        for signature in self.signatures:
            if signature.signature_id == signature_id:
                for key, value in updates.items():
                    if hasattr(signature, key):
                        setattr(signature, key, value)
                signature.updated_at = datetime.datetime.now().isoformat()
                print(f"Обновлена сигнатура: {signature_id}")
                return True
        return False

    def deactivate_signature(self, signature_id: str):
        """Деактивирует сигнатуру"""
        for signature in self.signatures:
            if signature.signature_id == signature_id:
                signature.is_active = False
                print(f"Деактивирована сигнатура: {signature_id}")
                return True
        return False

    def get_quarantine_files(self) -> List[str]:
        """Возвращает список файлов в карантине"""
        try:
            return [
                os.path.join(self.quarantine_dir, f)
                for f in os.listdir(self.quarantine_dir)
                if os.path.isfile(os.path.join(self.quarantine_dir, f))
            ]
        except Exception as e:
            print(f"Ошибка: {e}")
            return []

    def restore_from_quarantine(
        self, quarantine_path: str, restore_path: str
    ) -> bool:
        """Восстанавливает файл из карантина"""
        try:
            import shutil

            shutil.copy2(quarantine_path, restore_path)
            os.remove(quarantine_path)
            print(f"Файл восстановлен из карантина: {restore_path}")
            return True
        except Exception as e:
            print(f"Ошибка при восстановлении из карантина: {e}")
            return False

    def clear_quarantine(self):
        """Очищает карантин"""
        try:
            import shutil

            shutil.rmtree(self.quarantine_dir)
            os.makedirs(self.quarantine_dir, exist_ok=True)
            print("Карантин очищен")
        except Exception as e:
            print(f"Ошибка при очистке карантина: {e}")

    def export_detections(self, file_path: str):
        """Экспортирует обнаружения в файл"""
        try:
            data = {
                "detections": [d.to_dict() for d in self.detections],
                "scan_results": [r.to_dict() for r in self.scan_results],
                "exported_at": datetime.datetime.now().isoformat(),
            }

            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)

            print(f"Обнаружения экспортированы в: {file_path}")
        except Exception as e:
            print(f"Ошибка при экспорте: {e}")

    def import_detections(self, file_path: str):
        """Импортирует обнаружения из файла"""
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                data = json.load(f)

            if "detections" in data:
                for det_data in data["detections"]:
                    detection = MalwareDetection.from_dict(det_data)
                    self.detections.append(detection)

            if "scan_results" in data:
                for scan_data in data["scan_results"]:
                    scan_result = ScanResult.from_dict(scan_data)
                    self.scan_results.append(scan_result)

            print(f"Обнаружения импортированы из: {file_path}")
        except Exception as e:
            print(f"Ошибка при импорте: {e}")

    def get_recent_detections(self, hours: int = 24) -> List[MalwareDetection]:
        """Возвращает недавние обнаружения
        
        Args:
            hours: Количество часов назад для поиска обнаружений
            
        Returns:
            Список недавних обнаружений
        """
        # Проверяем тип параметра
        if not isinstance(hours, (int, float)):
            try:
                hours = int(hours)
            except (ValueError, TypeError):
                print(f"Некорректный тип параметра hours: {type(hours)}")
                return []
        
        # Ограничиваем диапазон
        hours = max(0, min(hours, 8760))  # от 0 до 1 года
        
        cutoff_time = datetime.datetime.now() - datetime.timedelta(hours=hours)
        recent_detections = []

        for detection in self.detections:
            try:
                detected_time = datetime.datetime.fromisoformat(
                    detection.detected_at
                )
                if detected_time >= cutoff_time:
                    recent_detections.append(detection)
            except (ValueError, TypeError) as e:
                print(f"Ошибка парсинга времени обнаружения: {e}")
                continue

        return recent_detections

    def simulate_malware_detection(
        self,
        file_path: str,
        malware_type: MalwareType,
        threat_level: ThreatLevel,
        confidence: float = 0.9,
    ):
        """Симулирует обнаружение вредоносного ПО для тестирования"""
        file_hash = (
            self._calculate_file_hash(file_path)
            if os.path.exists(file_path)
            else "simulated_hash"
        )
        file_size = (
            os.path.getsize(file_path) if os.path.exists(file_path) else 1024
        )

        detection = MalwareDetection(
            detection_id=f"sim_{datetime.datetime.now().timestamp()}",
            file_path=file_path,
            file_hash=file_hash,
            file_size=file_size,
            malware_type=malware_type,
            threat_level=threat_level,
            confidence=confidence,
            detection_method=DetectionMethod.MACHINE_LEARNING,
            description=f"Симулированное обнаружение {malware_type.value}",
            additional_info={"simulated": True},
        )

        self.detections.append(detection)
        print(f"Симулировано обнаружение: {file_path} - {malware_type.value}")
        return detection

    def __str__(self) -> str:
        """Возвращает строковое представление агента."""
        return f"MalwareDetectionAgent(name={self.name}, signatures={len(self.signatures)}, detections={len(self.detections)})"

    def __repr__(self) -> str:
        """Возвращает детальное строковое представление агента."""
        return (f"MalwareDetectionAgent(name='{self.name}', "
                f"signatures={len(self.signatures)}, detections={len(self.detections)}, "
                f"quarantine_dir='{self.quarantine_dir}')")
