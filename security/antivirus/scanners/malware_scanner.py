#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Malware Scanner - Комплексный сканер угроз
"""

import asyncio
import hashlib
import logging
import os
import re
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


class MalwareType(Enum):
    """Типы вредоносного ПО"""

    TROJAN = "trojan"
    WORM = "worm"
    VIRUS = "virus"
    ROOTKIT = "rootkit"
    SPYWARE = "spyware"
    ADWARE = "adware"
    RANSOMWARE = "ransomware"
    KEYLOGGER = "keylogger"
    BACKDOOR = "backdoor"
    BOTNET = "botnet"


@dataclass
class MalwarePattern:
    """Паттерн вредоносного ПО"""

    id: str
    name: str
    malware_type: MalwareType
    pattern: str
    description: str
    severity: int  # 1-10
    active: bool = True


@dataclass
class MalwareScanResult:
    """Результат сканирования на вредоносное ПО"""

    file_path: str
    clean: bool
    threats_found: List[MalwarePattern]
    scan_time: float
    file_hash: str
    file_size: int
    scanned_at: datetime


class MalwareScanner:
    """Комплексный сканер вредоносного ПО"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.patterns: List[MalwarePattern] = []
        self.scan_results: List[MalwareScanResult] = []

        # Инициализация паттернов
        self._initialize_patterns()

        logger.info("Malware Scanner инициализирован")

    def _initialize_patterns(self):
        """Инициализация паттернов вредоносного ПО"""
        patterns = [
            # Ransomware паттерны
            MalwarePattern(
                id="ransom_001",
                name="Ransomware Extension",
                malware_type=MalwareType.RANSOMWARE,
                pattern=r"\.(encrypted|locked|ransom|enc|locked)$",
                description="Расширения файлов, характерные для ransomware",
                severity=10,
            ),
            MalwarePattern(
                id="ransom_002",
                name="Ransomware Note",
                malware_type=MalwareType.RANSOMWARE,
                pattern=r"(?i)(ransom|decrypt|payment|bitcoin|wallet)",
                description="Текст, характерный для ransom-заметок",
                severity=9,
            ),
            # Trojan паттерны
            MalwarePattern(
                id="trojan_001",
                name="Suspicious PowerShell",
                malware_type=MalwareType.TROJAN,
                pattern=r"powershell.*-enc|powershell.*-e\s+[A-Za-z0-9+/=]+",
                description="Подозрительные команды PowerShell с кодированием",
                severity=8,
            ),
            MalwarePattern(
                id="trojan_002",
                name="Suspicious Download",
                malware_type=MalwareType.TROJAN,
                pattern=(
                    r"(?i)(download|wget|curl).*http[s]?://.*\."
                    r"(exe|bat|cmd|ps1)$"
                ),
                description="Подозрительные загрузки исполняемых файлов",
                severity=7,
            ),
            # Spyware паттерны
            MalwarePattern(
                id="spy_001",
                name="Keylogger Pattern",
                malware_type=MalwareType.KEYLOGGER,
                pattern=r"(?i)(keylog|keystroke|capture.*key|record.*input)",
                description="Паттерны, характерные для keylogger",
                severity=8,
            ),
            MalwarePattern(
                id="spy_002",
                name="Screen Capture",
                malware_type=MalwareType.SPYWARE,
                pattern=r"(?i)(screenshot|capture.*screen|record.*screen)",
                description="Паттерны захвата экрана",
                severity=6,
            ),
            # Backdoor паттерны
            MalwarePattern(
                id="backdoor_001",
                name="Reverse Shell",
                malware_type=MalwareType.BACKDOOR,
                pattern=r"(?i)(reverse.*shell|bind.*shell|nc.*-e|netcat.*-e)",
                description="Паттерны reverse shell",
                severity=9,
            ),
            MalwarePattern(
                id="backdoor_002",
                name="Suspicious Network",
                malware_type=MalwareType.BACKDOOR,
                pattern=(
                    r"(?i)(connect.*to.*\d+\.\d+\.\d+\.\d+|socket.*connect)"
                ),
                description="Подозрительные сетевые подключения",
                severity=7,
            ),
            # Botnet паттерны
            MalwarePattern(
                id="botnet_001",
                name="C&C Communication",
                malware_type=MalwareType.BOTNET,
                pattern=r"(?i)(command.*control|cc.*server|botnet.*server)",
                description="Паттерны связи с C&C серверами",
                severity=8,
            ),
            # Adware паттерны
            MalwarePattern(
                id="adware_001",
                name="Adware Behavior",
                malware_type=MalwareType.ADWARE,
                pattern=r"(?i)(popup|advertisement|banner.*ad|click.*fraud)",
                description="Паттерны поведения adware",
                severity=4,
            ),
            # Rootkit паттерны
            MalwarePattern(
                id="rootkit_001",
                name="Rootkit Hiding",
                malware_type=MalwareType.ROOTKIT,
                pattern=r"(?i)(hide.*process|hide.*file|stealth.*mode)",
                description="Паттерны сокрытия rootkit",
                severity=9,
            ),
        ]

        self.patterns = patterns
        logger.info(
            f"Загружено {len(self.patterns)} паттернов вредоносного ПО"
        )

    def _calculate_file_hash(self, file_path: str) -> str:
        """Вычисление хеша файла"""
        try:
            hash_md5 = hashlib.md5()
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except Exception as e:
            logger.error(f"Ошибка вычисления хеша файла {file_path}: {e}")
            return ""

    def _scan_file_content(self, file_path: str) -> List[MalwarePattern]:
        """Сканирование содержимого файла на вредоносное ПО"""
        threats_found = []

        try:
            # Чтение файла
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()

            # Проверка по паттернам
            for pattern in self.patterns:
                if not pattern.active:
                    continue

                try:
                    if re.search(
                        pattern.pattern, content, re.IGNORECASE | re.MULTILINE
                    ):
                        threats_found.append(pattern)
                        logger.warning(
                            f"Найден паттерн {pattern.name} "
                            f"в файле {file_path}"
                        )
                except re.error as e:
                    logger.error(
                        f"Ошибка в регулярном выражении "
                        f"{pattern.pattern}: {e}"
                    )

        except Exception as e:
            logger.error(f"Ошибка сканирования файла {file_path}: {e}")

        return threats_found

    async def scan_file(self, file_path: str) -> MalwareScanResult:
        """Сканирование файла на вредоносное ПО"""
        start_time = datetime.now()

        try:
            # Проверка существования файла
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"Файл не найден: {file_path}")

            # Получение информации о файле
            file_size = os.path.getsize(file_path)
            file_hash = self._calculate_file_hash(file_path)

            # Сканирование содержимого
            threats = self._scan_file_content(file_path)

            # Создание результата
            scan_time = (datetime.now() - start_time).total_seconds()
            result = MalwareScanResult(
                file_path=file_path,
                clean=len(threats) == 0,
                threats_found=threats,
                scan_time=scan_time,
                file_hash=file_hash,
                file_size=file_size,
                scanned_at=datetime.now(),
            )

            # Сохранение результата
            self.scan_results.append(result)

            if result.clean:
                logger.info(f"Файл {file_path} чист от вредоносного ПО")
            else:
                logger.warning(
                    f"Найдено {len(threats)} угроз в файле {file_path}"
                )

            return result

        except Exception as e:
            logger.error(f"Ошибка сканирования файла {file_path}: {e}")

            # Создание результата с ошибкой
            return MalwareScanResult(
                file_path=file_path,
                clean=True,
                threats_found=[],
                scan_time=0,
                file_hash="",
                file_size=0,
                scanned_at=datetime.now(),
            )

    async def scan_directory(
        self, directory_path: str, recursive: bool = True
    ) -> List[MalwareScanResult]:
        """Сканирование директории на вредоносное ПО"""
        results = []

        try:
            if not os.path.exists(directory_path):
                raise FileNotFoundError(
                    f"Директория не найдена: {directory_path}"
                )

            # Получение списка файлов
            files_to_scan = []
            for root, dirs, files in os.walk(directory_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    files_to_scan.append(file_path)

                if not recursive:
                    break

            logger.info(
                f"Найдено {len(files_to_scan)} файлов для сканирования"
            )

            # Сканирование файлов
            for file_path in files_to_scan:
                try:
                    result = await self.scan_file(file_path)
                    results.append(result)
                except Exception as e:
                    logger.error(f"Ошибка сканирования файла {file_path}: {e}")

            logger.info(
                f"Сканирование директории завершено: {len(results)} файлов"
            )

        except Exception as e:
            logger.error(
                f"Ошибка сканирования директории {directory_path}: {e}"
            )

        return results

    def get_scan_statistics(self) -> Dict[str, Any]:
        """Получение статистики сканирования"""
        total_scans = len(self.scan_results)
        threats_found = sum(1 for r in self.scan_results if not r.clean)
        total_threats = sum(len(r.threats_found) for r in self.scan_results)

        # Статистика по типам угроз
        threat_types = {}
        for result in self.scan_results:
            for threat in result.threats_found:
                threat_type = threat.malware_type.value
                threat_types[threat_type] = (
                    threat_types.get(threat_type, 0) + 1
                )

        return {
            "total_scans": total_scans,
            "threats_found": threats_found,
            "total_threats": total_threats,
            "threat_types": threat_types,
            "active_patterns": len([p for p in self.patterns if p.active]),
        }

    def get_status(self) -> Dict[str, Any]:
        """Получение статуса сканера"""
        stats = self.get_scan_statistics()

        return {
            "status": "healthy",
            "message": "Malware Scanner работает нормально",
            "statistics": stats,
            "patterns_loaded": len(self.patterns),
        }


# Пример использования
if __name__ == "__main__":
    # Настройка логирования
    logging.basicConfig(level=logging.INFO)

    # Создание Malware Scanner
    scanner = MalwareScanner()

    # Тестирование
    async def test_malware_scanner():
        # Создание тестового файла с подозрительным содержимым
        test_file = "test_malware.txt"
        with open(test_file, "w") as f:
            f.write(
                "This is a test file with suspicious PowerShell command: "
                "powershell -enc UwB0AGEAcgB0AC0AUwBsAGUAZQBwACAAMQAwAA=="
            )

        # Сканирование
        result = await scanner.scan_file(test_file)
        print(f"Результат: {result.clean}")
        print(f"Найденные угрозы: {[t.name for t in result.threats_found]}")

        # Статистика
        stats = scanner.get_scan_statistics()
        print(f"Статистика: {stats}")

        # Очистка
        os.remove(test_file)

    # Запуск теста
    asyncio.run(test_malware_scanner())
