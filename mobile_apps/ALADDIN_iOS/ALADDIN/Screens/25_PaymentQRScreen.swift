import SwiftUI

/**
 * üí≥ Payment QR Screen
 * –≠–∫—Ä–∞–Ω –æ–ø–ª–∞—Ç—ã —á–µ—Ä–µ–∑ QR-–∫–æ–¥ (–°–ë–ü, SberPay, Universal)
 * –î–ª—è —Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤–º–µ—Å—Ç–æ IAP
 */

struct PaymentQRScreen: View {
    
    // MARK: - Properties
    
    @Environment(\.dismiss) var dismiss
    @StateObject private var viewModel: PaymentQRViewModel
    
    let tariff: Tariff
    let onPaymentCompleted: () -> Void
    
    // MARK: - Init
    
    init(tariff: Tariff, onPaymentCompleted: @escaping () -> Void) {
        self.tariff = tariff
        self.onPaymentCompleted = onPaymentCompleted
        self._viewModel = StateObject(wrappedValue: PaymentQRViewModel(tariff: tariff))
    }
    
    // MARK: - Body
    
    var body: some View {
        ZStack {
            // Background
            LinearGradient.backgroundGradient
                .ignoresSafeArea()
            
            ScrollView {
                VStack(spacing: Spacing.xl) {
                    // Navigation Bar
                    ALADDINNavigationBar(
                        title: "–û–ü–õ–ê–¢–ê –ü–û–î–ü–ò–°–ö–ò",
                        subtitle: tariff.title,
                        showBackButton: true,
                        onBack: { dismiss() }
                    )
                    
                    // Timer
                    if let expiresAt = viewModel.expiresAt {
                        timerView(expiresAt: expiresAt)
                    }
                    
                    // QR Tabs
                    qrTabsView
                    
                    // Instructions
                    instructionsView
                    
                    // Check Payment Button
                    checkPaymentButton
                    
                    // Payment Info
                    paymentInfoView
                    
                    Spacer()
                }
                .padding(.horizontal, Spacing.screenPadding)
            }
            
            // Loading Overlay
            if viewModel.isLoading {
                Color.black.opacity(0.5)
                    .ignoresSafeArea()
                ProgressView()
                    .scaleEffect(1.5)
                    .tint(.secondaryGold)
            }
        }
        .navigationBarHidden(true)
        .onAppear {
            viewModel.createPayment()
            viewModel.startAutoCheck()
        }
        .onDisappear {
            viewModel.stopAutoCheck()
        }
        .alert("–û–ø–ª–∞—Ç–∞ —É—Å–ø–µ—à–Ω–∞!", isPresented: $viewModel.showSuccessAlert) {
            Button("–û—Ç–ª–∏—á–Ω–æ!") {
                onPaymentCompleted()
                dismiss()
            }
        } message: {
            Text("–ü–æ–¥–ø–∏—Å–∫–∞ \(tariff.title) –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!\n\n–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É!")
        }
        .alert("–û—à–∏–±–∫–∞", isPresented: $viewModel.showErrorAlert) {
            Button("OK") {
                viewModel.errorMessage = nil
            }
        } message: {
            if let error = viewModel.errorMessage {
                Text(error)
            }
        }
    }
    
    // MARK: - Timer View
    
    private func timerView(expiresAt: Date) -> some View {
        VStack(spacing: Spacing.xs) {
            Text("‚è∞")
                .font(.system(size: 32))
            
            Text(timeRemaining(until: expiresAt))
                .font(.h3)
                .foregroundColor(.secondaryGold)
            
            Text("–¥–æ –æ–∫–æ–Ω—á–∞–Ω–∏—è —Å—Ä–æ–∫–∞ –æ–ø–ª–∞—Ç—ã")
                .font(.caption)
                .foregroundColor(.textSecondary)
        }
        .padding(Spacing.m)
        .background(
            LinearGradient.cardGradient
                .appGlassmorphism()
        )
        .cornerRadius(CornerRadius.large)
        .cardShadow()
    }
    
    // MARK: - QR Tabs
    
    private var qrTabsView: some View {
        VStack(spacing: Spacing.m) {
            // Tab Selector
            HStack(spacing: Spacing.s) {
                ForEach(PaymentMethod.allCases, id: \.self) { method in
                    Button(action: {
                        viewModel.selectedMethod = method
                        HapticFeedback.selection()
                    }) {
                        VStack(spacing: Spacing.xxs) {
                            Text(method.icon)
                                .font(.system(size: 24))
                            Text(method.shortTitle)
                                .font(.captionBold)
                                .foregroundColor(viewModel.selectedMethod == method ? .secondaryGold : .textSecondary)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, Spacing.s)
                        .background(
                            viewModel.selectedMethod == method ?
                            Color.primaryBlue.opacity(0.3) :
                            Color.clear
                        )
                        .cornerRadius(CornerRadius.medium)
                    }
                }
            }
            
            // QR Code Display
            if let qrImage = viewModel.currentQRImage {
                VStack(spacing: Spacing.m) {
                    Text(viewModel.selectedMethod.fullTitle)
                        .font(.h3)
                        .foregroundColor(.textPrimary)
                    
                    AsyncImage(url: URL(string: qrImage)) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .interpolation(.none)
                                .scaledToFit()
                                .frame(width: 280, height: 280)
                                .background(Color.white)
                                .cornerRadius(CornerRadius.large)
                        case .failure(_):
                            placeholder
                        case .empty:
                            ProgressView()
                        @unknown default:
                            placeholder
                        }
                    }
                    
                    Text(viewModel.selectedMethod.instructions)
                        .font(.body)
                        .foregroundColor(.textSecondary)
                        .multilineTextAlignment(.center)
                }
                .padding(Spacing.cardPadding)
                .background(
                    LinearGradient.cardGradient
                        .appGlassmorphism()
                )
                .cornerRadius(CornerRadius.large)
                .cardShadow()
            }
        }
    }
    
    private var placeholder: some View {
        Rectangle()
            .fill(Color.surfaceDark)
            .frame(width: 280, height: 280)
            .cornerRadius(CornerRadius.large)
            .overlay(
                Text("QR-–∫–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                    .font(.caption)
                    .foregroundColor(.textSecondary)
            )
    }
    
    // MARK: - Instructions
    
    private var instructionsView: some View {
        VStack(alignment: .leading, spacing: Spacing.m) {
            Text("–ö–ê–ö –û–ü–õ–ê–¢–ò–¢–¨")
                .font(.h3)
                .foregroundColor(.textPrimary)
            
            VStack(alignment: .leading, spacing: Spacing.s) {
                instructionStep(number: 1, text: "–û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≤–∞—à–µ–≥–æ –±–∞–Ω–∫–∞")
                instructionStep(number: 2, text: "–ù–∞–π–¥–∏—Ç–µ —Ä–∞–∑–¥–µ–ª \"–û–ø–ª–∞—Ç–∞ –ø–æ QR\"")
                instructionStep(number: 3, text: "–û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –≤—ã—à–µ")
                instructionStep(number: 4, text: "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –æ–ø–ª–∞—Ç—É")
                instructionStep(number: 5, text: "–î–æ–∂–¥–∏—Ç–µ—Å—å –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏")
            }
        }
        .padding(Spacing.cardPadding)
        .background(
            LinearGradient.cardGradient
                .appGlassmorphism()
        )
        .cornerRadius(CornerRadius.large)
        .cardShadow()
    }
    
    private func instructionStep(number: Int, text: String) -> some View {
        HStack(spacing: Spacing.m) {
            Text("\(number)")
                .font(.h3)
                .foregroundColor(.secondaryGold)
                .frame(width: 32, height: 32)
                .background(Color.surfaceDark)
                .cornerRadius(CornerRadius.small)
            
            Text(text)
                .font(.body)
                .foregroundColor(.textPrimary)
        }
    }
    
    // MARK: - Check Payment Button
    
    private var checkPaymentButton: some View {
        PrimaryButton(title: "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É") {
            viewModel.checkPaymentStatus()
        }
        .disabled(viewModel.isLoading)
    }
    
    // MARK: - Payment Info
    
    private var paymentInfoView: some View {
        VStack(alignment: .leading, spacing: Spacing.m) {
            Text("–ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ü–õ–ê–¢–ï–ñ–ï")
                .font(.h3)
                .foregroundColor(.textPrimary)
            
            VStack(spacing: Spacing.s) {
                infoRow(label: "–¢–∞—Ä–∏—Ñ", value: tariff.title)
                infoRow(label: "–°—É–º–º–∞", value: tariff.price)
                infoRow(label: "–ü–µ—Ä–∏–æ–¥", value: tariff.period)
                
                if let merchantInfo = viewModel.merchantInfo {
                    Divider()
                        .background(Color.textTertiary)
                    
                    infoRow(label: "–ü–æ–ª—É—á–∞—Ç–µ–ª—å", value: merchantInfo.name)
                    infoRow(label: "–ö–∞—Ä—Ç–∞", value: merchantInfo.card)
                    infoRow(label: "–¢–µ–ª–µ—Ñ–æ–Ω –°–ë–ü", value: merchantInfo.phone)
                }
            }
        }
        .padding(Spacing.cardPadding)
        .background(
            LinearGradient.cardGradient
                .appGlassmorphism()
        )
        .cornerRadius(CornerRadius.large)
        .cardShadow()
    }
    
    private func infoRow(label: String, value: String) -> some View {
        HStack {
            Text(label)
                .font(.body)
                .foregroundColor(.textSecondary)
            Spacer()
            Text(value)
                .font(.bodyBold)
                .foregroundColor(.textPrimary)
        }
    }
    
    // MARK: - Helpers
    
    private func timeRemaining(until date: Date) -> String {
        let now = Date()
        let remaining = date.timeIntervalSince(now)
        
        if remaining <= 0 {
            return "–ò—Å—Ç–µ–∫ —Å—Ä–æ–∫"
        }
        
        let hours = Int(remaining) / 3600
        let minutes = (Int(remaining) % 3600) / 60
        
        return String(format: "%02d:%02d", hours, minutes)
    }
}

// MARK: - Payment Method Enum

enum PaymentMethod: String, CaseIterable {
    case sbp = "sbp"
    case sberpay = "sberpay"
    case universal = "universal"
    
    var icon: String {
        switch self {
        case .sbp: return "üí≥"
        case .sberpay: return "üè¶"
        case .universal: return "üì±"
        }
    }
    
    var shortTitle: String {
        switch self {
        case .sbp: return "–°–ë–ü"
        case .sberpay: return "–°–±–µ—ÄPay"
        case .universal: return "–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π"
        }
    }
    
    var fullTitle: String {
        switch self {
        case .sbp: return "–°–∏—Å—Ç–µ–º–∞ –ë—ã—Å—Ç—Ä—ã—Ö –ü–ª–∞—Ç–µ–∂–µ–π"
        case .sberpay: return "SberPay QR-–∫–æ–¥"
        case .universal: return "–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π QR-–∫–æ–¥"
        }
    }
    
    var instructions: String {
        switch self {
        case .sbp:
            return """
            –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –ª—é–±–æ–≥–æ –±–∞–Ω–∫–∞:
            ‚Ä¢ –°–±–µ—Ä–±–∞–Ω–∫ –û–Ω–ª–∞–π–Ω
            ‚Ä¢ –í–¢–ë –û–Ω–ª–∞–π–Ω
            ‚Ä¢ –¢–∏–Ω—å–∫–æ—Ñ—Ñ
            ‚Ä¢ –ê–ª—å—Ñ–∞-–ú–æ–±–∞–π–ª
            ‚Ä¢ –†–∞–π—Ñ—Ñ–∞–π–∑–µ–Ω –û–Ω–ª–∞–π–Ω
            ‚Ä¢ –ì–∞–∑–ø—Ä–æ–º–±–∞–Ω–∫
            ‚Ä¢ –†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫
            ‚Ä¢ –í–¢–ë24
            ‚Ä¢ –Æ–Ω–∏–ö—Ä–µ–¥–∏—Ç
            ‚Ä¢ –†—É—Å—Å–∫–∏–π –°—Ç–∞–Ω–¥–∞—Ä—Ç
            ‚Ä¢ –ú–ö–ë –û–Ω–ª–∞–π–Ω
            ‚Ä¢ –û—Ç–∫—Ä—ã—Ç–∏–µ
            –∏ –¥—Ä—É–≥–∏–µ
            """
        case .sberpay:
            return "–û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏\n–°–±–µ—Ä–ë–∞–Ω–∫ –û–Ω–ª–∞–π–Ω"
        case .universal:
            return """
            –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Å–ø–æ—Å–æ–± –¥–ª—è –≤—Å–µ—Ö –±–∞–Ω–∫–æ–≤.
            –û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≤–∞—à–µ–≥–æ –±–∞–Ω–∫–∞,
            –Ω–∞–π–¥–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ
            –¥–∞–Ω–Ω—ã–µ –∏–∑ QR-–∫–æ–¥–∞.
            """
        }
    }
}

// MARK: - Merchant Info

struct MerchantInfo {
    let name: String
    let card: String
    let phone: String
}

// MARK: - Preview

struct PaymentQRScreen_Previews: PreviewProvider {
    static var previews: some View {
        PaymentQRScreen(
            tariff: Tariff(
                id: "test",
                title: "–°–µ–º–µ–π–Ω—ã–π",
                price: "590 ‚ÇΩ",
                period: "–≤ –º–µ—Å—è—Ü",
                features: ["–î–æ 5 —É—Å—Ç—Ä–æ–π—Å—Ç–≤", "–ü–æ–ª–Ω–∞—è –∑–∞—â–∏—Ç–∞"],
                product: nil,
                isPurchased: false
            ),
            onPaymentCompleted: {}
        )
    }
}

