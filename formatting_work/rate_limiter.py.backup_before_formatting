#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RateLimiter - –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—å —Å–∫–æ—Ä–æ—Å—Ç–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
function_83: –ó–∞—â–∏—Ç–∞ –æ—Ç DDoS –∞—Ç–∞–∫ –∏ –∑–ª–æ—É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–π

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—É—é —Å–∏—Å—Ç–µ–º—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è AI —Å–∏—Å—Ç–µ–º—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏,
–≤–∫–ª—é—á–∞—é—â—É—é:
- –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã rate limiting (Token Bucket, Sliding Window, Fixed Window)
- –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∞–Ω–æ–º–∞–ª—å–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ —Ç—Ä–∞—Ñ–∏–∫–∞
- –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ª–∏–º–∏—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–≤–µ–¥–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- ML-–∞–Ω–∞–ª–∏–∑ –¥–ª—è –≤—ã—è–≤–ª–µ–Ω–∏—è DDoS –∞—Ç–∞–∫
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å–∏—Å—Ç–µ–º–æ–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏ –∞–ª–µ—Ä—Ç–∏–Ω–≥–∞
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –ª–∏–º–∏—Ç–æ–≤ (per IP, per user, per endpoint)
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ –∏ –∞–¥–∞–ø—Ç–∞—Ü–∏—è –ª–∏–º–∏—Ç–æ–≤
- –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –∞—É–¥–∏—Ç –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ (Prometheus, Grafana)
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤ –∏ API endpoints

–û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
1. –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
2. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∞–Ω–æ–º–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞
3. ML-–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ª–∏–º–∏—Ç–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
4. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å–∏—Å—Ç–µ–º–æ–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –º–µ—Ç—Ä–∏–∫
5. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π rate limiting
6. –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ª–∏–º–∏—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ –ø–æ–≤–µ–¥–µ–Ω–∏—è
7. –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –∞—É–¥–∏—Ç –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
8. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
9. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ —Ä–æ–ª–µ–π
10. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Å–±–æ–µ–≤

–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏:
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç asyncio –¥–ª—è –≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–π –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
- –ü—Ä–∏–º–µ–Ω—è–µ—Ç ML –∞–ª–≥–æ—Ä–∏—Ç–º—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–∞—Ñ–∏–∫–∞
- –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç Redis –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–π –ª–∏–º–∏—Ç–æ–≤
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç SQLAlchemy –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
- –ü—Ä–∏–º–µ–Ω—è–µ—Ç Pydantic –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö
- –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç Prometheus –¥–ª—è –º–µ—Ç—Ä–∏–∫
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Celery –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á
- –ü—Ä–∏–º–µ–Ω—è–µ—Ç nginx –¥–ª—è reverse proxy
- –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç ELK stack –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è

–ê–≤—Ç–æ—Ä: ALADDIN Security System
–í–µ—Ä—Å–∏—è: 2.0
–î–∞—Ç–∞: 2025-01-27
–õ–∏—Ü–µ–Ω–∑–∏—è: MIT
"""

import asyncio
import hashlib
import logging
import time
import json

from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import threading
from collections import defaultdict, deque

# –í–Ω–µ—à–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
import redis
import sqlalchemy
from sqlalchemy import create_engine, Column, String, Integer, DateTime, Boolean, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from pydantic import BaseModel, Field, validator
from prometheus_client import Counter, Histogram, Gauge
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler

# –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∏–º–ø–æ—Ä—Ç—ã
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from core.base import CoreBase
from core.service_base import ServiceBase
from core.security_base import SecurityBase
from core.database import DatabaseManager
from core.configuration import ConfigurationManager

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Prometheus –º–µ—Ç—Ä–∏–∫–∏
REQUEST_COUNT = Counter('rate_limiter_requests_total', 'Total rate limiter requests', ['algorithm', 'client_type', 'status'])
REQUEST_DURATION = Histogram('rate_limiter_request_duration_seconds', 'Rate limiter request duration', ['algorithm', 'client_type'])
ACTIVE_LIMITS = Gauge('rate_limiter_active_limits', 'Active rate limits per client type', ['client_type'])
BLOCKED_REQUESTS = Counter('rate_limiter_blocked_requests_total', 'Blocked requests by rate limiter', ['reason', 'client_type'])
ML_ANOMALIES = Counter('rate_limiter_ml_anomalies_total', 'ML detected anomalies', ['anomaly_type', 'severity'])

# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
Base = declarative_base()



class RateLimitRecord(Base):
    """–ó–∞–ø–∏—Å—å –æ –ª–∏–º–∏—Ç–µ —Å–∫–æ—Ä–æ—Å—Ç–∏"""
    __tablename__ = 'rate_limit_records'

    id = Column(String, primary_key=True)
    client_id = Column(String, nullable=False, index=True)
    client_type = Column(String, nullable=False, index=True)
    algorithm = Column(String, nullable=False)
    limit_value = Column(Integer, nullable=False)
    window_size = Column(Integer, nullable=False)
    current_usage = Column(Integer, default=0)
    last_reset = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    request_metadata = Column(JSON, default={})



class RateLimitViolation(Base):
    """–ó–∞–ø–∏—Å—å –æ –Ω–∞—Ä—É—à–µ–Ω–∏–∏ –ª–∏–º–∏—Ç–∞"""
    __tablename__ = 'rate_limit_violations'

    id = Column(String, primary_key=True)
    client_id = Column(String, nullable=False, index=True)
    client_type = Column(String, nullable=False, index=True)
    algorithm = Column(String, nullable=False)
    limit_value = Column(Integer, nullable=False)
    actual_usage = Column(Integer, nullable=False)
    violation_time = Column(DateTime, default=datetime.utcnow)
    ip_address = Column(String)
    user_agent = Column(String)
    endpoint = Column(String)
    severity = Column(String, default='medium')
    is_blocked = Column(Boolean, default=False)
    request_metadata = Column(JSON, default={})

# Pydantic –º–æ–¥–µ–ª–∏


class RateLimitConfig(BaseModel):
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ª–∏–º–∏—Ç–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏"""
    client_id: str = Field(..., description="–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞")
    client_type: str = Field(..., description="–¢–∏–ø –∫–ª–∏–µ–Ω—Ç–∞ (ip, user, endpoint)")
    algorithm: str = Field(..., description="–ê–ª–≥–æ—Ä–∏—Ç–º rate limiting")
    limit_value: int = Field(..., gt=0, description="–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤")
    window_size: int = Field(..., gt=0, description="–†–∞–∑–º–µ—Ä –æ–∫–Ω–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö")
    burst_limit: Optional[int] = Field(None, gt=0, description="–õ–∏–º–∏—Ç –≤—Å–ø–ª–µ—Å–∫–∞")
    adaptive: bool = Field(True, description="–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ª–∏–º–∏—Ç—ã")
    ml_enabled: bool = Field(True, description="ML –∞–Ω–∞–ª–∏–∑ –≤–∫–ª—é—á–µ–Ω")

    @validator('algorithm')
    def validate_algorithm(cls, v):
        allowed = ['token_bucket', 'sliding_window', 'fixed_window', 'adaptive']
        if v not in allowed:
            raise ValueError(f'Algorithm must be one of {allowed}')
        return v



class RateLimitRequest(BaseModel):
    """–ó–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É –ª–∏–º–∏—Ç–∞"""
    client_id: str = Field(..., description="–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞")
    client_type: str = Field(..., description="–¢–∏–ø –∫–ª–∏–µ–Ω—Ç–∞")
    endpoint: Optional[str] = Field(None, description="API endpoint")
    ip_address: Optional[str] = Field(None, description="IP –∞–¥—Ä–µ—Å")
    user_agent: Optional[str] = Field(None, description="User Agent")
    request_size: int = Field(1, ge=1, description="–†–∞–∑–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞")
    priority: int = Field(1, ge=1, le=10, description="–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∑–∞–ø—Ä–æ—Å–∞")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ")



class RateLimitResponse(BaseModel):
    """–û—Ç–≤–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å –ª–∏–º–∏—Ç–∞"""
    allowed: bool = Field(..., description="–†–∞–∑—Ä–µ—à–µ–Ω –ª–∏ –∑–∞–ø—Ä–æ—Å")
    remaining: int = Field(..., description="–û—Å—Ç–∞–≤—à–∏–µ—Å—è –∑–∞–ø—Ä–æ—Å—ã")
    reset_time: datetime = Field(..., description="–í—Ä–µ–º—è —Å–±—Ä–æ—Å–∞ –ª–∏–º–∏—Ç–∞")
    retry_after: Optional[int] = Field(None, description="–í—Ä–µ–º—è –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–∏")
    reason: Optional[str] = Field(None, description="–ü—Ä–∏—á–∏–Ω–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ")

# –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è


class RateLimitAlgorithm(Enum):
    """–ê–ª–≥–æ—Ä–∏—Ç–º—ã rate limiting"""
    TOKEN_BUCKET = "token_bucket"
    SLIDING_WINDOW = "sliding_window"
    FIXED_WINDOW = "fixed_window"
    ADAPTIVE = "adaptive"



class ClientType(Enum):
    """–¢–∏–ø—ã –∫–ª–∏–µ–Ω—Ç–æ–≤"""
    IP = "ip"
    USER = "user"
    ENDPOINT = "endpoint"
    GLOBAL = "global"



class ViolationSeverity(Enum):
    """–£—Ä–æ–≤–Ω–∏ —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç–∏ –Ω–∞—Ä—É—à–µ–Ω–∏–π"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

# –ö–ª–∞—Å—Å—ã –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
@dataclass


class TokenBucket:
    """Token Bucket –∞–ª–≥–æ—Ä–∏—Ç–º"""
    capacity: int
    tokens: float = 0
    last_refill: float = field(default_factory=time.time)
    refill_rate: float = 1.0

    def consume(self, tokens: int = 1) -> bool:
        """–ü–æ–ø—ã—Ç–∫–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç—å —Ç–æ–∫–µ–Ω—ã"""
        now = time.time()
        time_passed = now - self.last_refill
        self.tokens = min(self.capacity, self.tokens + time_passed * self.refill_rate)
        self.last_refill = now

        if self.tokens >= tokens:
            self.tokens -= tokens
            return True
        return False

    def get_remaining(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Ç–æ–∫–µ–Ω—ã"""
        now = time.time()
        time_passed = now - self.last_refill
        current_tokens = min(self.capacity, self.tokens + time_passed * self.refill_rate)
        return int(current_tokens)

@dataclass


class SlidingWindow:
    """Sliding Window –∞–ª–≥–æ—Ä–∏—Ç–º"""
    limit: int
    window_size: int
    requests: deque = field(default_factory=deque)

    def consume(self) -> bool:
        """–ü–æ–ø—ã—Ç–∫–∞ –¥–æ–±–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å"""
        now = time.time()
        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø—Ä–æ—Å—ã
        while self.requests and self.requests[0] <= now - self.window_size:
            self.requests.popleft()

        if len(self.requests) < self.limit:
            self.requests.append(now)
            return True
        return False

    def get_remaining(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –∑–∞–ø—Ä–æ—Å—ã"""
        now = time.time()
        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø—Ä–æ—Å—ã
        while self.requests and self.requests[0] <= now - self.window_size:
            self.requests.popleft()
        return max(0, self.limit - len(self.requests))

@dataclass


class FixedWindow:
    """Fixed Window –∞–ª–≥–æ—Ä–∏—Ç–º"""
    limit: int
    window_size: int
    current_window: int = 0
    current_count: int = 0
    window_start: float = field(default_factory=time.time)

    def consume(self) -> bool:
        """–ü–æ–ø—ã—Ç–∫–∞ –¥–æ–±–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å"""
        now = time.time()
        current_window = int(now // self.window_size)

        if current_window != self.current_window:
            self.current_window = current_window
            self.current_count = 0
            self.window_start = now

        if self.current_count < self.limit:
            self.current_count += 1
            return True
        return False

    def get_remaining(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –∑–∞–ø—Ä–æ—Å—ã"""
        now = time.time()
        current_window = int(now // self.window_size)

        if current_window != self.current_window:
            return self.limit

        return max(0, self.limit - self.current_count)

# –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å RateLimiter


class RateLimiter(SecurityBase):
    """
    –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—å —Å–∫–æ—Ä–æ—Å—Ç–∏ –∑–∞–ø—Ä–æ—Å–æ–≤

    –ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—É—é —Å–∏—Å—Ç–µ–º—É rate limiting —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π:
    - –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
    - ML –∞–Ω–∞–ª–∏–∑–∞ –∞–Ω–æ–º–∞–ª–∏–π
    - –ê–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö –ª–∏–º–∏—Ç–æ–≤
    - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º
    """

    def __init__(self, name: str = "RateLimiter", config: Optional[Dict[str, Any]] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è RateLimiter

        Args:
            name: –ò–º—è RateLimiter
            config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        """
        super().__init__(name, config)

        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        self.default_config = {
            "redis_url": "redis://localhost:6379/0",
            "database_url": "sqlite:///rate_limiter.db",
            "default_algorithm": "adaptive",
            "default_window_size": 60,  # —Å–µ–∫—É–Ω–¥
            "default_limit": 100,  # –∑–∞–ø—Ä–æ—Å–æ–≤
            "ml_enabled": True,
            "adaptive_learning": True,
            "anomaly_threshold": 0.1,
            "max_adaptive_factor": 2.0,
            "min_adaptive_factor": 0.1,
            "cleanup_interval": 300,  # —Å–µ–∫—É–Ω–¥
            "metrics_enabled": True,
            "logging_enabled": True,
            "enable_circuit_breaker": True,
            "circuit_breaker_threshold": 10,
            "circuit_breaker_timeout": 60
        }

        # –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π
        self.config = {**self.default_config, **(config or {})}

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self.redis_client: Optional[redis.Redis] = None
        self.db_engine: Optional[sqlalchemy.Engine] = None
        self.db_session: Optional[sqlalchemy.orm.Session] = None
        self.rate_limits: Dict[str, Any] = {}
        self.violations: Dict[str, List[RateLimitViolation]] = defaultdict(list)
        self.ml_model: Optional[IsolationForest] = None
        self.scaler: Optional[StandardScaler] = None
        self.adaptive_factors: Dict[str, float] = defaultdict(lambda: 1.0)
        self.circuit_breakers: Dict[str, Dict[str, Any]] = {}

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            "total_requests": 0,
            "allowed_requests": 0,
            "blocked_requests": 0,
            "ml_anomalies": 0,
            "adaptive_adjustments": 0
        }

        # –ü–æ—Ç–æ–∫–∏
        self.cleanup_thread: Optional[threading.Thread] = None
        self.ml_thread: Optional[threading.Thread] = None
        self.running = False

        # –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        self.lock = threading.RLock()

        self.logger.info(f"RateLimiter {name} –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

    async def start(self) -> bool:
        """–ó–∞–ø—É—Å–∫ RateLimiter"""
        try:
            self.logger.info("–ó–∞–ø—É—Å–∫ RateLimiter")

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            await self._initialize_database()

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Redis
            await self._initialize_redis()

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ML –º–æ–¥–µ–ª–∏
            if self.config["ml_enabled"]:
                await self._initialize_ml_model()

            # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤—ã—Ö –ø–æ—Ç–æ–∫–æ–≤
            self.running = True
            self.cleanup_thread = threading.Thread(target=self._cleanup_worker, daemon=True)
            self.cleanup_thread.start()

            if self.config["ml_enabled"]:
                self.ml_thread = threading.Thread(target=self._ml_worker, daemon=True)
                self.ml_thread.start()

            self.logger.info("RateLimiter —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω")
            return True

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ RateLimiter: {e}")
            return False

    async def stop(self) -> bool:
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ RateLimiter"""
        try:
            self.logger.info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ RateLimiter")

            self.running = False

            # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ—Ç–æ–∫–æ–≤
            if self.cleanup_thread and self.cleanup_thread.is_alive():
                self.cleanup_thread.join(timeout=5)

            if self.ml_thread and self.ml_thread.is_alive():
                self.ml_thread.join(timeout=5)

            # –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            if self.redis_client:
                self.redis_client.close()

            if self.db_session:
                self.db_session.close()

            if self.db_engine:
                self.db_engine.dispose()

            self.logger.info("RateLimiter —É—Å–ø–µ—à–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            return True

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ RateLimiter: {e}")
            return False

    async def _initialize_database(self) -> None:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        try:
            database_url = self.config.get('database_url', 'sqlite:///rate_limiter.db')
            self.db_engine = create_engine(database_url, echo=False)

            # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü
            Base.metadata.create_all(self.db_engine)

            # –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏
            Session = sessionmaker(bind=self.db_engine)
            self.db_session = Session()

            self.logger.info("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö RateLimiter –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")
            raise

    async def _initialize_redis(self) -> None:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Redis"""
        try:
            redis_url = self.config.get('redis_url', 'redis://localhost:6379/0')
            self.redis_client = redis.from_url(redis_url, decode_responses=True)

            # –¢–µ—Å—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            self.redis_client.ping()

            self.logger.info("Redis –∫–ª–∏–µ–Ω—Ç RateLimiter –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Redis: {e}")
            raise

    async def _initialize_ml_model(self) -> None:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ML –º–æ–¥–µ–ª–∏"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∞–Ω–æ–º–∞–ª–∏–π
            self.ml_model = IsolationForest(
                contamination=self.config["anomaly_threshold"],
                random_state=42
            )

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∫–µ–π–ª–µ—Ä–∞
            self.scaler = StandardScaler()

            self.logger.info("ML –º–æ–¥–µ–ª—å RateLimiter –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ML –º–æ–¥–µ–ª–∏: {e}")
            raise

    async def check_rate_limit(self, request: RateLimitRequest) -> RateLimitResponse:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞

        Args:
            request: –ó–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É –ª–∏–º–∏—Ç–∞

        Returns:
            RateLimitResponse: –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏
        """
        start_time = time.time()

        try:
            with self.lock:
                self.stats["total_requests"] += 1

            # –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ª–∏–º–∏—Ç–∞
            limit_config = await self._get_limit_config(request)

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ circuit breaker
            if self.config["enable_circuit_breaker"]:
                if not await self._is_circuit_breaker_closed(request.client_id):
                    return RateLimitResponse(
                        allowed=False,
                        remaining=0,
                        reset_time=datetime.utcnow() + timedelta(seconds=limit_config.window_size),
                        retry_after=limit_config.window_size,
                        reason="Circuit breaker open"
                    )

            # ML –∞–Ω–∞–ª–∏–∑ –∞–Ω–æ–º–∞–ª–∏–π
            if self.config["ml_enabled"]:
                is_anomaly = await self._detect_anomaly(request)
                if is_anomaly:
                    with self.lock:
                        self.stats["ml_anomalies"] += 1
                    ML_ANOMALIES.labels(anomaly_type="request_pattern", severity="high").inc()

            # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ rate limiting
            allowed, remaining, reset_time = await self._apply_rate_limit(request, limit_config)

            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            with self.lock:
                if allowed:
                    self.stats["allowed_requests"] += 1
                else:
                    self.stats["blocked_requests"] += 1

            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ circuit breaker
            if self.config["enable_circuit_breaker"]:
                await self._update_circuit_breaker(request.client_id, allowed)

            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
            duration = time.time() - start_time
            REQUEST_DURATION.labels(
                algorithm=limit_config.algorithm,
                client_type=request.client_type
            ).observe(duration)

            REQUEST_COUNT.labels(
                algorithm=limit_config.algorithm,
                client_type=request.client_type,
                status="allowed" if allowed else "blocked"
            ).inc()

            if not allowed:
                BLOCKED_REQUESTS.labels(
                    reason="rate_limit_exceeded",
                    client_type=request.client_type
                ).inc()

            return RateLimitResponse(
                allowed=allowed,
                remaining=remaining,
                reset_time=reset_time,
                retry_after=limit_config.window_size if not allowed else None,
                reason="Rate limit exceeded" if not allowed else None,
                request_metadata={
                    "algorithm": limit_config.algorithm,
                    "duration_ms": duration * 1000,
                    "is_anomaly": is_anomaly if self.config["ml_enabled"] else False
                }
            )

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏–º–∏—Ç–∞: {e}")
            return RateLimitResponse(
                allowed=False,
                remaining=0,
                reset_time=datetime.utcnow() + timedelta(seconds=60),
                retry_after=60,
                reason=f"Internal error: {str(e)}"
            )

    async def _get_limit_config(self, request: RateLimitRequest) -> RateLimitConfig:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ª–∏–º–∏—Ç–∞ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞"""
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—ç—à–∞
        cache_key = f"rate_limit_config:{request.client_id}:{request.client_type}"

        if self.redis_client:
            cached_config = self.redis_client.get(cache_key)
            if cached_config:
                config_data = json.loads(cached_config)
                return RateLimitConfig(**config_data)

        # –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        if self.db_session:
            record = self.db_session.query(RateLimitRecord).filter(
                RateLimitRecord.client_id == request.client_id,
                RateLimitRecord.client_type == request.client_type,
                RateLimitRecord.is_active
            ).first()

            if record:
                config = RateLimitConfig(
                    client_id=record.client_id,
                    client_type=record.client_type,
                    algorithm=record.algorithm,
                    limit_value=record.limit_value,
                    window_size=record.window_size,
                    adaptive=True,
                    ml_enabled=self.config["ml_enabled"]
                )

                # –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ
                if self.redis_client:
                    self.redis_client.setex(
                        cache_key,
                        300,  # 5 –º–∏–Ω—É—Ç
                        json.dumps(config.dict())
                    )

                return config

        # –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        default_config = RateLimitConfig(
            client_id=request.client_id,
            client_type=request.client_type,
            algorithm=self.config["default_algorithm"],
            limit_value=self.config["default_limit"],
            window_size=self.config["default_window_size"],
            adaptive=self.config["adaptive_learning"],
            ml_enabled=self.config["ml_enabled"]
        )

        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        await self._save_limit_config(default_config)

        return default_config

    async def _apply_rate_limit(self, request: RateLimitRequest, config: RateLimitConfig) -> Tuple[bool, int, datetime]:
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ rate limiting"""
        client_key = f"{request.client_id}:{request.client_type}"

        # –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –ª–∏–º–∏—Ç–µ—Ä–∞
        if client_key not in self.rate_limits:
            self.rate_limits[client_key] = self._create_limiter(config)

        limiter = self.rate_limits[client_key]

        # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ —Ñ–∞–∫—Ç–æ—Ä–∞
        if config.adaptive and client_key in self.adaptive_factors:
            adaptive_factor = self.adaptive_factors[client_key]
            if hasattr(limiter, 'limit'):
                limiter.limit = int(config.limit_value * adaptive_factor)
            elif hasattr(limiter, 'capacity'):
                limiter.capacity = int(config.limit_value * adaptive_factor)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞
        allowed = limiter.consume(request.request_size)
        remaining = limiter.get_remaining()

        # –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å–±—Ä–æ—Å–∞
        reset_time = datetime.utcnow() + timedelta(seconds=config.window_size)

        # –ó–∞–ø–∏—Å—å –Ω–∞—Ä—É—à–µ–Ω–∏—è
        if not allowed:
            await self._record_violation(request, config, limiter)

        return allowed, remaining, reset_time

    def _create_limiter(self, config: RateLimitConfig):
        """–°–æ–∑–¥–∞–Ω–∏–µ –ª–∏–º–∏—Ç–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        algorithm = RateLimitAlgorithm(config.algorithm)

        if algorithm == RateLimitAlgorithm.TOKEN_BUCKET:
            return TokenBucket(
                capacity=config.limit_value,
                refill_rate=config.limit_value / config.window_size
            )
        elif algorithm == RateLimitAlgorithm.SLIDING_WINDOW:
            return SlidingWindow(
                limit=config.limit_value,
                window_size=config.window_size
            )
        elif algorithm == RateLimitAlgorithm.FIXED_WINDOW:
            return FixedWindow(
                limit=config.limit_value,
                window_size=config.window_size
            )
        else:  # ADAPTIVE
            return SlidingWindow(
                limit=config.limit_value,
                window_size=config.window_size
            )

    async def _detect_anomaly(self, request: RateLimitRequest) -> bool:
        """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∞–Ω–æ–º–∞–ª–∏–π –≤ –∑–∞–ø—Ä–æ—Å–µ —Å –ø–æ–º–æ—â—å—é ML"""
        if not self.ml_model or not self.scaler:
            return False

        try:
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
            features = self._extract_features(request)

            if len(features) == 0:
                return False

            # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
            features_scaled = self.scaler.transform([features])

            # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –∞–Ω–æ–º–∞–ª–∏–∏
            anomaly_score = self.ml_model.decision_function(features_scaled)[0]
            is_anomaly = anomaly_score < 0

            return is_anomaly

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∞–Ω–æ–º–∞–ª–∏–∏: {e}")
            return False

    def _extract_features(self, request: RateLimitRequest) -> List[float]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –¥–ª—è ML –∞–Ω–∞–ª–∏–∑–∞"""
        features = []

        # –í—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
        now = datetime.utcnow()
        features.extend([
            now.hour,
            now.weekday(),
            now.day,
            now.month
        ])

        # –ü—Ä–∏–∑–Ω–∞–∫–∏ –∑–∞–ø—Ä–æ—Å–∞
        features.extend([
            request.request_size,
            request.priority,
                len(request.request_metadata) if request.request_metadata else 0
        ])

        # –ü—Ä–∏–∑–Ω–∞–∫–∏ –∫–ª–∏–µ–Ω—Ç–∞
        if request.ip_address:
            # –ü—Ä–æ—Å—Ç–∞—è —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è IP
            ip_hash = int(hashlib.md5(request.ip_address.encode()).hexdigest()[:8], 16)
            features.append(ip_hash % 1000)  # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
        else:
            features.append(0)

        if request.user_agent:
            features.append(len(request.user_agent))
        else:
            features.append(0)

        return features

    async def _record_violation(self, request: RateLimitRequest, config: RateLimitConfig, limiter) -> None:
        """–ó–∞–ø–∏—Å—å –Ω–∞—Ä—É—à–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞"""
        try:
            violation = RateLimitViolation(
                id=f"violation_{int(time.time() * 1000)}_{request.client_id}",
                client_id=request.client_id,
                client_type=request.client_type,
                algorithm=config.algorithm,
                limit_value=config.limit_value,
                actual_usage=limiter.get_remaining() + request.request_size,
                ip_address=request.ip_address,
                user_agent=request.user_agent,
                endpoint=request.endpoint,
                severity=self._calculate_severity(request, config),
                is_blocked=True,
                request_metadata=request.request_metadata
            )

            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
            if self.db_session:
                self.db_session.add(violation)
                self.db_session.commit()

            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫—ç—à –Ω–∞—Ä—É—à–µ–Ω–∏–π
            client_key = f"{request.client_id}:{request.client_type}"
            self.violations[client_key].append(violation)

            # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –∫—ç—à–∞
            if len(self.violations[client_key]) > 100:
                self.violations[client_key] = self.violations[client_key][-50:]

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –Ω–∞—Ä—É—à–µ–Ω–∏—è: {e}")

    def _calculate_severity(self, request: RateLimitRequest, config: RateLimitConfig) -> str:
        """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç–∏ –Ω–∞—Ä—É—à–µ–Ω–∏—è"""
        # –ü—Ä–æ—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç–∏
        if request.priority >= 8:
            return ViolationSeverity.CRITICAL.value
        elif request.priority >= 5:
            return ViolationSeverity.HIGH.value
        elif request.priority >= 3:
            return ViolationSeverity.MEDIUM.value
        else:
            return ViolationSeverity.LOW.value

    async def _save_limit_config(self, config: RateLimitConfig) -> None:
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ª–∏–º–∏—Ç–∞"""
        try:
            record = RateLimitRecord(
                id=f"config_{config.client_id}_{config.client_type}",
                client_id=config.client_id,
                client_type=config.client_type,
                algorithm=config.algorithm,
                limit_value=config.limit_value,
                window_size=config.window_size,
                request_metadata=config.dict()
            )

            if self.db_session:
                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏
                existing = self.db_session.query(RateLimitRecord).filter(
                    RateLimitRecord.id == record.id
                ).first()

                if existing:
                    existing.algorithm = record.algorithm
                    existing.limit_value = record.limit_value
                    existing.window_size = record.window_size
                    existing.updated_at = datetime.utcnow()
                else:
                    self.db_session.add(record)

                self.db_session.commit()

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")

    async def _is_circuit_breaker_closed(self, client_id: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è circuit breaker"""
        if client_id not in self.circuit_breakers:
            return True

        cb = self.circuit_breakers[client_id]
        now = time.time()

        if cb["state"] == "open":
            if now - cb["last_failure_time"] > cb["timeout"]:
                cb["state"] = "half_open"
                return True
            return False

        return True

    async def _update_circuit_breaker(self, client_id: str, success: bool) -> None:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è circuit breaker"""
        if client_id not in self.circuit_breakers:
            self.circuit_breakers[client_id] = {
                "state": "closed",
                "failure_count": 0,
                "last_failure_time": 0,
                "timeout": self.config["circuit_breaker_timeout"]
            }

        cb = self.circuit_breakers[client_id]

        if success:
            if cb["state"] == "half_open":
                cb["state"] = "closed"
            cb["failure_count"] = 0
        else:
            cb["failure_count"] += 1
            cb["last_failure_time"] = time.time()

            if cb["failure_count"] >= self.config["circuit_breaker_threshold"]:
                cb["state"] = "open"

    def _cleanup_worker(self) -> None:
        """–§–æ–Ω–æ–≤—ã–π –ø—Ä–æ—Ü–µ—Å—Å –æ—á–∏—Å—Ç–∫–∏"""
        while self.running:
            try:
                time.sleep(self.config["cleanup_interval"])

                with self.lock:
                    # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –ª–∏–º–∏—Ç–µ—Ä–æ–≤
                    current_time = time.time()
                    keys_to_remove = []

                    for key, limiter in self.rate_limits.items():
                        if hasattr(limiter, 'last_refill'):
                            if current_time - limiter.last_refill > 3600:  # 1 —á–∞—Å
                                keys_to_remove.append(key)

                    for key in keys_to_remove:
                        del self.rate_limits[key]

                    # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –Ω–∞—Ä—É—à–µ–Ω–∏–π
                    for client_key in self.violations:
                        violations = self.violations[client_key]
                        cutoff_time = current_time - 86400  # 24 —á–∞—Å–∞

                        self.violations[client_key] = [
                            v for v in violations
                            if v.violation_time.timestamp() > cutoff_time
                        ]

                self.logger.debug("–û—á–∏—Å—Ç–∫–∞ RateLimiter –∑–∞–≤–µ—Ä—à–µ–Ω–∞")

            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –æ—á–∏—Å—Ç–∫–∏: {e}")

    def _ml_worker(self) -> None:
        """–§–æ–Ω–æ–≤—ã–π –ø—Ä–æ—Ü–µ—Å—Å ML –æ–±—É—á–µ–Ω–∏—è"""
        while self.running:
            try:
                time.sleep(3600)  # –û–±—É—á–µ–Ω–∏–µ –∫–∞–∂–¥—ã–π —á–∞—Å

                if not self.ml_model or not self.scaler:
                    continue

                # –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
                training_data = []

                with self.lock:
                    for client_key, violations in self.violations.items():
                        for violation in violations[-100:]:  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 100 –Ω–∞—Ä—É—à–µ–Ω–∏–π
                            features = self._extract_features_from_violation(violation)
                            if features:
                                training_data.append(features)

                if len(training_data) < 10:  # –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö
                    continue

                # –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
                X = np.array(training_data)
                self.scaler.fit(X)
                X_scaled = self.scaler.transform(X)
                self.ml_model.fit(X_scaled)

                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö —Ñ–∞–∫—Ç–æ—Ä–æ–≤
                self._update_adaptive_factors()

                self.logger.info("ML –º–æ–¥–µ–ª—å RateLimiter –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∞")

            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ –≤ ML –ø—Ä–æ—Ü–µ—Å—Å–µ: {e}")

    def _extract_features_from_violation(self, violation: RateLimitViolation) -> List[float]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –∏–∑ –Ω–∞—Ä—É—à–µ–Ω–∏—è"""
        features = []

        # –í—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
        violation_time = violation.violation_time
        features.extend([
            violation_time.hour,
            violation_time.weekday(),
            violation_time.day,
            violation_time.month
        ])

        # –ü—Ä–∏–∑–Ω–∞–∫–∏ –Ω–∞—Ä—É—à–µ–Ω–∏—è
        features.extend([
            violation.actual_usage,
            violation.limit_value,
                len(violation.request_metadata) if violation.request_metadata else 0
        ])

        # –ü—Ä–∏–∑–Ω–∞–∫–∏ IP
        if violation.ip_address:
            ip_hash = int(hashlib.md5(violation.ip_address.encode()).hexdigest()[:8], 16)
            features.append(ip_hash % 1000)
        else:
            features.append(0)

        return features

    async def _update_adaptive_factors(self) -> None:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö —Ñ–∞–∫—Ç–æ—Ä–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ ML –∞–Ω–∞–ª–∏–∑–∞"""
        try:
            with self.lock:
                for client_key, violations in self.violations.items():
                    if len(violations) < 5:  # –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö
                        continue

                    # –ê–Ω–∞–ª–∏–∑ –ø–∞—Ç—Ç–µ—Ä–Ω–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–π
                    recent_violations = violations[-10:]  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –Ω–∞—Ä—É—à–µ–Ω–∏–π
                    violation_rate = len(recent_violations) / 10.0

                    # –ê–¥–∞–ø—Ç–∞—Ü–∏—è —Ñ–∞–∫—Ç–æ—Ä–∞
                    if violation_rate > 0.7:  # –í—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å –Ω–∞—Ä—É—à–µ–Ω–∏–π
                        self.adaptive_factors[client_key] = max(
                            self.config["min_adaptive_factor"],
                            self.adaptive_factors[client_key] * 0.9
                        )
                    elif violation_rate < 0.1:  # –ù–∏–∑–∫–∏–π —É—Ä–æ–≤–µ–Ω—å –Ω–∞—Ä—É—à–µ–Ω–∏–π
                        self.adaptive_factors[client_key] = min(
                            self.config["max_adaptive_factor"],
                            self.adaptive_factors[client_key] * 1.1
                        )

                    self.stats["adaptive_adjustments"] += 1

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö —Ñ–∞–∫—Ç–æ—Ä–æ–≤: {e}")

    async def get_status(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ RateLimiter"""
        with self.lock:
            return {
                "name": self.name,
                "status": "running" if self.running else "stopped",
                "stats": self.stats.copy(),
                "active_limits": len(self.rate_limits),
                "total_violations": sum(len(v) for v in self.violations.values()),
                "adaptive_factors": dict(self.adaptive_factors),
                "circuit_breakers": {
                    client_id: {
                        "state": cb["state"],
                        "failure_count": cb["failure_count"]
                    }
                    for client_id, cb in self.circuit_breakers.items()
                },
                "config": {
                    "ml_enabled": self.config["ml_enabled"],
                    "adaptive_learning": self.config["adaptive_learning"],
                    "default_algorithm": self.config["default_algorithm"],
                    "default_limit": self.config["default_limit"]
                }
            }

    async def reset_limits(self, client_id: Optional[str] = None) -> bool:
        """–°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ –∏–ª–∏ –≤—Å–µ—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤"""
        try:
            with self.lock:
                if client_id:
                    # –°–±—Ä–æ—Å –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
                    keys_to_remove = [key for key in self.rate_limits.keys() if key.startswith(f"{client_id}:")]
                    for key in keys_to_remove:
                        del self.rate_limits[key]

                    if client_id in self.adaptive_factors:
                        del self.adaptive_factors[client_id]

                    if client_id in self.circuit_breakers:
                        del self.circuit_breakers[client_id]
                else:
                    # –°–±—Ä–æ—Å –≤—Å–µ—Ö –ª–∏–º–∏—Ç–æ–≤
                    self.rate_limits.clear()
                    self.adaptive_factors.clear()
                    self.circuit_breakers.clear()

                self.logger.info(f"–õ–∏–º–∏—Ç—ã —Å–±—Ä–æ—à–µ–Ω—ã –¥–ª—è {'–≤—Å–µ—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤' if not client_id else client_id}")
                return True

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–±—Ä–æ—Å–∞ –ª–∏–º–∏—Ç–æ–≤: {e}")
            return False

# API —Å–µ—Ä–≤–µ—Ä –¥–ª—è RateLimiter
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

app = FastAPI(title="RateLimiter API", version="2.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä RateLimiter
rate_limiter: Optional[RateLimiter] = None

@app.on_event("startup")
async def startup_event():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è RateLimiter –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ"""
    global rate_limiter
    rate_limiter = RateLimiter("RateLimiterServer")
    await rate_limiter.start()

@app.on_event("shutdown")
async def shutdown_event():
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ RateLimiter –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏"""
    global rate_limiter
    if rate_limiter:
        await rate_limiter.stop()

@app.get("/health")
async def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è RateLimiter"""
    return {"status": "healthy", "service": "RateLimiter"}

@app.get("/status")
async def get_status():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ RateLimiter"""
    if not rate_limiter:
        raise HTTPException(status_code=503, detail="RateLimiter not initialized")

    return await rate_limiter.get_status()

@app.post("/check")
async def check_rate_limit(request: RateLimitRequest):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏"""
    if not rate_limiter:
        raise HTTPException(status_code=503, detail="RateLimiter not initialized")

    return await rate_limiter.check_rate_limit(request)

@app.post("/reset")
async def reset_limits(client_id: Optional[str] = None):
    """–°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤"""
    if not rate_limiter:
        raise HTTPException(status_code=503, detail="RateLimiter not initialized")

    success = await rate_limiter.reset_limits(client_id)
    if not success:
        raise HTTPException(status_code=500, detail="Failed to reset limits")

    return {"message": "Limits reset successfully"}

@app.get("/metrics")
async def get_metrics():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ Prometheus"""
    from prometheus_client import generate_latest, CONTENT_TYPE_LATEST
    from fastapi.responses import Response

    return Response(
        generate_latest(),
        media_type=CONTENT_TYPE_LATEST
    )

# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞


def main():
    """–ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ RateLimiter"""
    uvicorn.run(
        "rate_limiter:app",
        host="0.0.0.0",
        port=8007,
        reload=False,
        log_level="info"
    )

if __name__ == "__main__":
    main()

# –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
async def test_rate_limiter():
    """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ RateLimiter"""
    print("üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ RateLimiter...")

    # –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞
    limiter = RateLimiter("TestRateLimiter")

    try:
        # –ó–∞–ø—É—Å–∫
        await limiter.start()
        print("‚úÖ RateLimiter –∑–∞–ø—É—â–µ–Ω")

        # –¢–µ—Å—Ç 1: –û–±—ã—á–Ω—ã–π –∑–∞–ø—Ä–æ—Å
        request = RateLimitRequest(
            client_id="test_client_1",
            client_type="ip",
            ip_address="192.168.1.1",
            user_agent="TestAgent/1.0"
        )

        response = await limiter.check_rate_limit(request)
        print(f"‚úÖ –¢–µ—Å—Ç 1 - –û–±—ã—á–Ω—ã–π –∑–∞–ø—Ä–æ—Å: {response.allowed}")

        # –¢–µ—Å—Ç 2: –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
        for i in range(5):
            request = RateLimitRequest(
                client_id="test_client_2",
                client_type="user",
                request_size=1,
                priority=5
            )
            response = await limiter.check_rate_limit(request)
            print(f"‚úÖ –¢–µ—Å—Ç 2.{i+1} - –ó–∞–ø—Ä–æ—Å {i+1}: {response.allowed}, –æ—Å—Ç–∞–ª–æ—Å—å: {response.remaining}")

        # –¢–µ—Å—Ç 3: –ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ –ª–∏–º–∏—Ç–∞
        request = RateLimitRequest(
            client_id="test_client_3",
            client_type="endpoint",
            request_size=1000,  # –ë–æ–ª—å—à–æ–π –∑–∞–ø—Ä–æ—Å
            priority=1
        )
        response = await limiter.check_rate_limit(request)
        print(f"‚úÖ –¢–µ—Å—Ç 3 - –ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ –ª–∏–º–∏—Ç–∞: {response.allowed}, –ø—Ä–∏—á–∏–Ω–∞: {response.reason}")

        # –¢–µ—Å—Ç 4: –°—Ç–∞—Ç—É—Å
        status = await limiter.get_status()
        print(f"‚úÖ –¢–µ—Å—Ç 4 - –°—Ç–∞—Ç—É—Å: {status['status']}, –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–∏–º–∏—Ç–æ–≤: {status['active_limits']}")

        # –¢–µ—Å—Ç 5: –°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤
        success = await limiter.reset_limits("test_client_1")
        print(f"‚úÖ –¢–µ—Å—Ç 5 - –°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤: {success}")

        print("üéâ –í—Å–µ —Ç–µ—Å—Ç—ã RateLimiter –ø—Ä–æ—à–ª–∏ —É—Å–ø–µ—à–Ω–æ!")

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")

    finally:
        # –û—Å—Ç–∞–Ω–æ–≤–∫–∞
        await limiter.stop()
        print("‚úÖ RateLimiter –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

# –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ –ø—Ä–∏ –ø—Ä—è–º–æ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏
if __name__ == "__main__":
    asyncio.run(test_rate_limiter())
