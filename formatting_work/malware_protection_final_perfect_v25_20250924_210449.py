# -*- coding: utf-8 -*-
"""
ALADDIN Security System - Malware Protection Service
Система защиты от вредоносного ПО для семей
Автор: ALADDIN Security Team
Версия: 1.0
Дата: 2025-09-02
"""
import asyncio
import hashlib
import logging
import os
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from functools import lru_cache
from typing import Any, Dict, List, Optional, Set

from core.base import SecurityBase


class MalwareType(Enum):
    """Типы вредоносного ПО"""

    VIRUS = "virus"
    TROJAN = "trojan"
    WORM = "worm"
    RANSOMWARE = "ransomware"
    SPYWARE = "spyware"
    ADWARE = "adware"
    ROOTKIT = "rootkit"
    KEYLOGGER = "keylogger"
    BACKDOOR = "backdoor"
    BOTNET = "botnet"
    PHISHING = "phishing"
    SCAREWARE = "scareware"


class MalwareSeverity(Enum):
    """Уровни серьезности вредоносного ПО"""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ProtectionAction(Enum):
    """Действия защиты"""

    QUARANTINE = "quarantine"
    DELETE = "delete"
    BLOCK_ACCESS = "block_access"
    ALERT_USER = "alert_user"
    ALERT_ADMIN = "alert_admin"
    SCAN_SYSTEM = "scan_system"
    UPDATE_SIGNATURES = "update_signatures"
    ISOLATE_NETWORK = "isolate_network"


class MalwareStatus(Enum):
    """Статусы вредоносного ПО"""

    DETECTED = "detected"
    QUARANTINED = "quarantined"
    REMOVED = "removed"
    BLOCKED = "blocked"
    INVESTIGATING = "investigating"
    FALSE_POSITIVE = "false_positive"


@dataclass
class MalwareDetection:
    """Обнаружение вредоносного ПО"""

    detection_id: str
    malware_type: MalwareType
    severity: MalwareSeverity
    file_path: str
    file_hash: str
    file_size: int
    timestamp: datetime
    description: str
    status: MalwareStatus
    protection_actions: List[ProtectionAction] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ProtectionRule:
    """Правило защиты"""

    rule_id: str
    name: str
    description: str
    malware_type: MalwareType
    severity_threshold: MalwareSeverity
    conditions: Dict[str, Any]
    actions: List[ProtectionAction]
    enabled: bool = True
    family_specific: bool = False
    age_group: Optional[str] = None


@dataclass
class MalwareSignature:
    """Сигнатура вредоносного ПО"""

    signature_id: str
    name: str
    description: str
    malware_type: MalwareType
    patterns: List[str]
    file_hashes: List[str]
    confidence_threshold: float
    family_protection: bool = True


class MalwareProtectionService(SecurityBase):
    """Сервис защиты от вредоносного ПО для семей"""

    def __init__(
        self,
        name: str = "MalwareProtection",
        config: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(name, config)
        self.logger = logging.getLogger(__name__)
        # Хранилища данных
        self.malware_detections: Dict[str, MalwareDetection] = {}
        self.protection_rules: Dict[str, ProtectionRule] = {}
        self.malware_signatures: Dict[str, MalwareSignature] = {}
        self.quarantined_files: Set[str] = set()
        self.blocked_hashes: Set[str] = set()
        self.family_protection_history: Dict[str, List[str]] = (
            {}
        )  # user_id -> detection_ids
        # Настройки защиты
        self.protection_thresholds = {
            MalwareSeverity.LOW: 0.3,
            MalwareSeverity.MEDIUM: 0.5,
            MalwareSeverity.HIGH: 0.7,
            MalwareSeverity.CRITICAL: 0.9,
        }
        # Семейные настройки
        self.family_protection_enabled = True
        self.child_protection_mode = True
        self.elderly_protection_mode = True
        self.real_time_scanning = True

        # Кэширование и производительность
        self._file_hash_cache: Dict[str, str] = {}
        self._signature_cache: Dict[str, float] = {}
        self._performance_metrics: Dict[str, Any] = {
            "scan_count": 0,
            "total_scan_time": 0.0,
            "average_scan_time": 0.0,
            "cache_hits": 0,
            "cache_misses": 0,
            "detections_found": 0,
            "false_positives": 0,
        }

        # Конфигурируемые настройки
        self.max_file_size = (
            config.get("max_file_size", 100 * 1024 * 1024)
            if config
            else 100 * 1024 * 1024
        )  # 100MB
        self.cache_ttl = (
            config.get("cache_ttl", 3600) if config else 3600
        )  # 1 час
        self.scan_timeout = (
            config.get("scan_timeout", 30) if config else 30
        )  # 30 секунд
        self.enable_async = (
            config.get("enable_async", True) if config else True
        )
        self.automatic_quarantine = True
        # Инициализация
        self._initialize_malware_signatures()
        self._initialize_protection_rules()
        self._setup_family_protection()

    def _initialize_malware_signatures(self):
        """Инициализация сигнатур вредоносного ПО"""
        signatures = [
            MalwareSignature(
                signature_id="virus_generic",
                name="Универсальный вирус",
                description="Общие признаки вирусного ПО",
                malware_type=MalwareType.VIRUS,
                patterns=["virus", "malware", "trojan", "worm"],
                file_hashes=["d41d8cd98f00b204e9800998ecf8427e"],
                confidence_threshold=0.6,
                family_protection=True,
            ),
            MalwareSignature(
                signature_id="ransomware_crypto",
                name="Крипто-вымогатель",
                description="Программы-вымогатели с шифрованием",
                malware_type=MalwareType.RANSOMWARE,
                patterns=["encrypt", "decrypt", "ransom", "bitcoin", "crypto"],
                file_hashes=[],
                confidence_threshold=0.8,
                family_protection=True,
            ),
            MalwareSignature(
                signature_id="spyware_keylogger",
                name="Шпионское ПО и кейлоггеры",
                description="Программы для кражи данных",
                malware_type=MalwareType.SPYWARE,
                patterns=["keylog", "spy", "steal", "password", "credit"],
                file_hashes=[],
                confidence_threshold=0.7,
                family_protection=True,
            ),
            MalwareSignature(
                signature_id="adware_popup",
                name="Рекламное ПО",
                description="Назойливая реклама и всплывающие окна",
                malware_type=MalwareType.ADWARE,
                patterns=["adware", "popup", "advertisement", "banner"],
                file_hashes=[],
                confidence_threshold=0.5,
                family_protection=True,
            ),
            MalwareSignature(
                signature_id="phishing_fake",
                name="Фишинговые сайты",
                description="Поддельные сайты для кражи данных",
                malware_type=MalwareType.PHISHING,
                patterns=["phishing", "fake", "scam", "bank", "paypal"],
                file_hashes=[],
                confidence_threshold=0.8,
                family_protection=True,
            ),
            MalwareSignature(
                signature_id="child_exploitation",
                name="Эксплуатация детей",
                description="Вредоносное ПО для эксплуатации "
                "несовершеннолетних",
                malware_type=MalwareType.SPYWARE,
                patterns=["child", "minor", "exploit", "grooming"],
                file_hashes=[],
                confidence_threshold=0.9,
                family_protection=True,
            ),
            MalwareSignature(
                signature_id="elderly_fraud",
                name="Мошенничество с пожилыми",
                description="Вредоносное ПО для мошенничества с пожилыми",
                malware_type=MalwareType.SPYWARE,
                patterns=["elderly", "senior", "fraud", "scam", "money"],
                file_hashes=[],
                confidence_threshold=0.8,
                family_protection=True,
            ),
            MalwareSignature(
                signature_id="rootkit_hidden",
                name="Руткит",
                description="Скрытое вредоносное ПО",
                malware_type=MalwareType.ROOTKIT,
                patterns=["rootkit", "hidden", "stealth", "kernel"],
                file_hashes=[],
                confidence_threshold=0.8,
                family_protection=True,
            ),
        ]
        for signature in signatures:
            self.malware_signatures[signature.signature_id] = signature
        self.log_activity(
            f"Инициализировано {len(signatures)} сигнатур вредоносного ПО"
        )

    def _initialize_protection_rules(self):
        """Инициализация правил защиты"""
        rules = [
            ProtectionRule(
                rule_id="quarantine_virus",
                name="Карантин вирусов",
                description="Помещение вирусов в карантин",
                malware_type=MalwareType.VIRUS,
                severity_threshold=MalwareSeverity.MEDIUM,
                conditions={"auto_quarantine": True},
                actions=[
                    ProtectionAction.QUARANTINE,
                    ProtectionAction.ALERT_USER,
                ],
                family_specific=True,
            ),
            ProtectionRule(
                rule_id="block_ransomware",
                name="Блокировка вымогателей",
                description="Немедленная блокировка программ-вымогателей",
                malware_type=MalwareType.RANSOMWARE,
                severity_threshold=MalwareSeverity.CRITICAL,
                conditions={"immediate_block": True},
                actions=[
                    ProtectionAction.BLOCK_ACCESS,
                    ProtectionAction.ALERT_ADMIN,
                    ProtectionAction.ISOLATE_NETWORK,
                ],
                family_specific=True,
            ),
            ProtectionRule(
                rule_id="remove_spyware",
                name="Удаление шпионского ПО",
                description="Удаление программ-шпионов",
                malware_type=MalwareType.SPYWARE,
                severity_threshold=MalwareSeverity.HIGH,
                conditions={"auto_remove": True},
                actions=[ProtectionAction.DELETE, ProtectionAction.ALERT_USER],
                family_specific=True,
            ),
            ProtectionRule(
                rule_id="block_adware",
                name="Блокировка рекламного ПО",
                description="Блокировка назойливой рекламы",
                malware_type=MalwareType.ADWARE,
                severity_threshold=MalwareSeverity.LOW,
                conditions={"block_ads": True},
                actions=[
                    ProtectionAction.BLOCK_ACCESS,
                    ProtectionAction.ALERT_USER,
                ],
                family_specific=True,
            ),
            ProtectionRule(
                rule_id="child_protection",
                name="Защита детей",
                description="Специальная защита для детей",
                malware_type=MalwareType.SPYWARE,
                severity_threshold=MalwareSeverity.CRITICAL,
                conditions={
                    "age_group": "child",
                    "inappropriate_content": True,
                },
                actions=[
                    ProtectionAction.BLOCK_ACCESS,
                    ProtectionAction.ALERT_ADMIN,
                    ProtectionAction.QUARANTINE,
                ],
                family_specific=True,
                age_group="child",
            ),
            ProtectionRule(
                rule_id="elderly_protection",
                name="Защита пожилых",
                description="Специальная защита для пожилых",
                malware_type=MalwareType.SPYWARE,
                severity_threshold=MalwareSeverity.HIGH,
                conditions={"age_group": "elderly", "financial_fraud": True},
                actions=[
                    ProtectionAction.BLOCK_ACCESS,
                    ProtectionAction.ALERT_ADMIN,
                    ProtectionAction.QUARANTINE,
                ],
                family_specific=True,
                age_group="elderly",
            ),
            ProtectionRule(
                rule_id="scan_system",
                name="Сканирование системы",
                description="Полное сканирование системы при обнаружении",
                malware_type=MalwareType.VIRUS,
                severity_threshold=MalwareSeverity.HIGH,
                conditions={"full_scan": True},
                actions=[
                    ProtectionAction.SCAN_SYSTEM,
                    ProtectionAction.UPDATE_SIGNATURES,
                ],
                family_specific=True,
            ),
        ]
        for rule in rules:
            self.protection_rules[rule.rule_id] = rule
        self.log_activity(f"Инициализировано {len(rules)} правил защиты")

    def _setup_family_protection(self):
        """Настройка семейной защиты"""
        self.family_protection_settings = {
            "child_protection": {
                "enabled": True,
                "strict_mode": True,
                "parent_notifications": True,
                "blocked_content_types": [
                    "inappropriate",
                    "adult",
                    "violence",
                    "gambling",
                ],
            },
            "elderly_protection": {
                "enabled": True,
                "fraud_detection": True,
                "family_notifications": True,
                "suspicious_behavior_alerts": True,
            },
            "general_family": {
                "unified_protection": True,
                "shared_threat_intelligence": True,
                "family_aware_blocking": True,
                "real_time_scanning": True,
            },
        }
        self.log_activity("Настроена семейная защита от вредоносного ПО")

    def scan_file(
        self,
        file_path: str,
        user_id: Optional[str] = None,
        user_age: Optional[int] = None,
    ) -> List[MalwareDetection]:
        """
        Сканирование файла на наличие вредоносного ПО с поддержкой
        семейной защиты.

        Выполняет комплексное сканирование файла по сигнатурам
        вредоносного ПО, учитывая возрастные ограничения и семейные
        настройки безопасности.

        Args:
            file_path (str): Путь к файлу для сканирования. Должен существовать
                и быть доступным для чтения.
            user_id (Optional[str], optional): Уникальный идентификатор
                пользователя для семейной защиты. Если указан, применяются
                специальные правила защиты для детей и пожилых.
            user_age (Optional[int], optional): Возраст пользователя
                (0-150 лет).
                Используется для применения возрастных ограничений и
                специальных правил защиты.

        Returns:
            List[MalwareDetection]: Список обнаружений вредоносного ПО.
                Каждое обнаружение содержит:
                - detection_id: Уникальный идентификатор обнаружения
                - malware_type: Тип вредоносного ПО (VIRUS, TROJAN, etc.)
                - severity: Уровень серьезности (LOW, MEDIUM, HIGH, CRITICAL)
                - file_path: Путь к сканируемому файлу
                - file_hash: MD5 хеш файла
                - timestamp: Время обнаружения
                - description: Описание угрозы
                - status: Статус обработки (DETECTED, QUARANTINED, etc.)

        Raises:
            FileNotFoundError: Если указанный файл не существует
            PermissionError: Если нет прав на чтение файла
            ValueError: Если параметры некорректны (неверный возраст,
                пустой путь)
            OSError: Если произошла ошибка при чтении файла

        Example:
            >>> mp = MalwareProtectionService()
            >>> detections = mp.scan_file(
            ...     '/path/to/file.exe', user_id='user123', user_age=25
            ... )
            >>> for detection in detections:
            ...     print(f"Найдена угроза: {detection.description}")
            ...     print(f"Тип: {detection.malware_type.value}")
            ...     print(f"Серьезность: {detection.severity.value}")

        Note:
            - Сканирование выполняется по всем активным сигнатурам
            - Для семейной защиты учитываются возрастные ограничения
            - Результаты сохраняются в истории семейной защиты
            - Все обнаружения логируются для последующего анализа

        See Also:
            - protect_against_malware: Применение защитных мер
            - get_malware_summary: Получение сводки по угрозам
            - get_family_protection_status: Статус семейной защиты
        """
        # Расширенная валидация параметров
        if not file_path or not isinstance(file_path, str):
            raise ValueError("file_path должен быть непустой строкой")

        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Файл не найден: {file_path}")

        if not os.access(file_path, os.R_OK):
            raise PermissionError(f"Нет прав на чтение файла: {file_path}")

        if user_age is not None:
            if not isinstance(user_age, int) or user_age < 0 or user_age > 150:
                raise ValueError(
                    "user_age должен быть целым числом от 0 до 150"
                )

        if user_id is not None and not isinstance(user_id, str):
            raise ValueError("user_id должен быть строкой или None")

        # Проверка размера файла (максимум 100MB)
        file_size = os.path.getsize(file_path)
        if file_size > 100 * 1024 * 1024:  # 100MB
            raise ValueError(
                f"Файл слишком большой: {file_size} байт (максимум 100MB)"
            )

        try:
            # Начинаем измерение времени
            start_time = time.time()

            detections = []
            # Получаем информацию о файле
            file_size = os.path.getsize(file_path)
            file_hash = self._calculate_file_hash(file_path)
            # Проверяем по сигнатурам
            for signature_id, signature in self.malware_signatures.items():
                confidence = self._calculate_signature_confidence(
                    file_path, signature, file_hash
                )
                if confidence >= signature.confidence_threshold:
                    # Создаем обнаружение
                    detection = MalwareDetection(
                        detection_id=self._generate_detection_id(),
                        malware_type=signature.malware_type,
                        severity=self._determine_severity(
                            confidence, signature
                        ),
                        file_path=file_path,
                        file_hash=file_hash,
                        file_size=file_size,
                        timestamp=datetime.now(),
                        description=f"Обнаружен {signature.name}",
                        status=MalwareStatus.DETECTED,
                        metadata={
                            "signature_id": signature_id,
                            "confidence": confidence,
                            "user_id": user_id,
                            "user_age": user_age,
                            "family_protection": signature.family_protection,
                        },
                    )
                    detections.append(detection)
                    self.malware_detections[detection.detection_id] = detection
                    # Добавляем в семейную историю
                    if user_id:
                        if user_id not in self.family_protection_history:
                            self.family_protection_history[user_id] = []
                        self.family_protection_history[user_id].append(
                            detection.detection_id
                        )
                    # Добавляем событие безопасности
                    self.add_security_event(
                        event_type="malware_detected",
                        severity=detection.severity.value,
                        description=f"Обнаружено вредоносное ПО: "
                        f"{signature.name}",
                        source="MalwareProtection",
                        metadata={
                            "detection_id": detection.detection_id,
                            "malware_type": signature.malware_type.value,
                            "severity": detection.severity.value,
                            "confidence": confidence,
                            "file_path": file_path,
                            "file_hash": file_hash,
                            "user_id": user_id,
                            "user_age": user_age,
                        },
                    )

            # Обновляем метрики производительности
            scan_time = time.time() - start_time
            self._performance_metrics["scan_count"] += 1
            self._performance_metrics["total_scan_time"] += scan_time
            self._performance_metrics["detections_found"] += len(detections)

            return detections

        except FileNotFoundError:
            self.logger.error(f"Файл не найден: {file_path}")
            raise
        except PermissionError:
            self.logger.error(f"Нет прав доступа к файлу: {file_path}")
            raise
        except ValueError as e:
            self.logger.error(f"Некорректные параметры: {e}")
            raise
        except OSError as e:
            self.logger.error(
                f"Ошибка файловой системы при сканировании {file_path}: {e}"
            )
            raise
        except Exception as e:
            self.logger.error(
                f"Неожиданная ошибка при сканировании {file_path}: {e}"
            )
            raise RuntimeError(f"Ошибка сканирования файла: {e}") from e

    @lru_cache(maxsize=1000)
    def _calculate_file_hash(self, file_path: str) -> str:
        """
        Расчет хеша файла с кэшированием.

        Использует LRU кэш для оптимизации повторных вычислений хешей
        одинаковых файлов.

        Args:
            file_path (str): Путь к файлу для расчета хеша

        Returns:
            str: MD5 хеш файла в шестнадцатеричном формате

        Raises:
            OSError: Если не удалось прочитать файл
            ValueError: Если файл пустой или поврежден
        """
        try:
            # Проверяем кэш
            if file_path in self._file_hash_cache:
                self._performance_metrics["cache_hits"] += 1
                return self._file_hash_cache[file_path]

            self._performance_metrics["cache_misses"] += 1

            hash_md5 = hashlib.md5()
            file_size = 0

            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
                    file_size += len(chunk)

            if file_size == 0:
                raise ValueError(f"Файл пустой: {file_path}")

            file_hash = hash_md5.hexdigest()

            # Сохраняем в кэш
            self._file_hash_cache[file_path] = file_hash

            return file_hash

        except Exception as e:
            self.logger.error(f"Ошибка расчета хеша файла {file_path}: {e}")
            raise

    def _calculate_signature_confidence(
        self, file_path: str, signature: MalwareSignature, file_hash: str
    ) -> float:
        """Расчет уверенности в сигнатуре"""
        try:
            confidence = 0.0
            # Проверка хеша файла
            if file_hash in signature.file_hashes:
                confidence += 0.8
            # Проверка паттернов в имени файла
            file_name = os.path.basename(file_path).lower()
            for pattern in signature.patterns:
                if pattern.lower() in file_name:
                    confidence += 0.2
            # Проверка паттернов в содержимом файла (упрощенная)
            try:
                with open(
                    file_path, "r", encoding="utf-8", errors="ignore"
                ) as f:
                    content = f.read(
                        1024
                    ).lower()  # Читаем первые 1024 символа
                    for pattern in signature.patterns:
                        if pattern.lower() in content:
                            confidence += 0.3
            except Exception:
                pass  # Игнорируем ошибки чтения файла
            # Дополнительные факторы для семейной защиты
            if signature.family_protection:
                confidence += 0.1  # Дополнительная защита для семей
            return min(confidence, 1.0)
        except Exception as e:
            self.logger.error(f"Ошибка расчета уверенности: {e}")
            return 0.0

    def _determine_severity(
        self, confidence: float, signature: MalwareSignature
    ) -> MalwareSeverity:
        """Определение серьезности вредоносного ПО"""
        if confidence >= 0.9:
            return MalwareSeverity.CRITICAL
        elif confidence >= 0.7:
            return MalwareSeverity.HIGH
        elif confidence >= 0.5:
            return MalwareSeverity.MEDIUM
        else:
            return MalwareSeverity.LOW

    async def scan_file_async(
        self,
        file_path: str,
        user_id: Optional[str] = None,
        user_age: Optional[int] = None,
    ) -> List[MalwareDetection]:
        """
        Асинхронное сканирование файла на наличие вредоносного ПО.

        Асинхронная версия scan_file для улучшенной производительности
        при обработке больших файлов или множественных запросов.

        Args:
            file_path (str): Путь к файлу для сканирования
            user_id (Optional[str], optional): Идентификатор пользователя
            user_age (Optional[int], optional): Возраст пользователя

        Returns:
            List[MalwareDetection]: Список обнаружений вредоносного ПО

        Raises:
            FileNotFoundError: Если файл не найден
            PermissionError: Если нет прав на чтение файла
            ValueError: Если параметры некорректны
            OSError: Если произошла ошибка файловой системы
        """
        # Валидация параметров (такая же как в синхронной версии)
        if not file_path or not isinstance(file_path, str):
            raise ValueError("file_path должен быть непустой строкой")

        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Файл не найден: {file_path}")

        if not os.access(file_path, os.R_OK):
            raise PermissionError(f"Нет прав на чтение файла: {file_path}")

        if user_age is not None:
            if not isinstance(user_age, int) or user_age < 0 or user_age > 150:
                raise ValueError(
                    "user_age должен быть целым числом от 0 до 150"
                )

        if user_id is not None and not isinstance(user_id, str):
            raise ValueError("user_id должен быть строкой или None")

        # Проверка размера файла
        file_size = os.path.getsize(file_path)
        if file_size > 100 * 1024 * 1024:  # 100MB
            raise ValueError(
                f"Файл слишком большой: {file_size} байт (максимум 100MB)"
            )

        try:
            detections = []
            # Асинхронно получаем информацию о файле
            file_hash = await self._calculate_file_hash_async(file_path)

            # Асинхронно проверяем по сигнатурам
            for signature_id, signature in self.malware_signatures.items():
                # Проверяем семейную защиту
                if user_id and signature.family_protection:
                    if not self._is_family_protection_applicable(
                        user_age, signature.family_protection
                    ):
                        continue

                # Асинхронно рассчитываем уверенность
                confidence = await self._calculate_signature_confidence_async(
                    file_path, signature, file_hash
                )

                if confidence >= 0.3:  # Порог обнаружения
                    detection = MalwareDetection(
                        detection_id=(
                            f"malware_{int(time.time())}_{signature_id}"
                        ),
                        malware_type=signature.malware_type,
                        severity=self._determine_severity(
                            confidence, signature
                        ),
                        file_path=file_path,
                        file_hash=file_hash,
                        timestamp=datetime.now(),
                        description=f"Обнаружено: {signature.name}",
                        status=MalwareStatus.DETECTED,
                        metadata={
                            "signature_id": signature_id,
                            "confidence": confidence,
                            "user_id": user_id,
                            "user_age": user_age,
                            "family_protection": signature.family_protection,
                        },
                    )
                    detections.append(detection)
                    self.malware_detections[detection.detection_id] = detection

                    # Добавляем в семейную историю
                    if user_id:
                        if user_id not in self.family_protection_history:
                            self.family_protection_history[user_id] = []
                        self.family_protection_history[user_id].append(
                            detection.detection_id
                        )

                    # Добавляем событие безопасности
                    self.add_security_event(
                        event_type="malware_detected",
                        severity=detection.severity.value,
                        description=(
                            f"Обнаружено вредоносное ПО: {signature.name}"
                        ),
                        source="MalwareProtection",
                        metadata={
                            "detection_id": detection.detection_id,
                            "malware_type": signature.malware_type.value,
                            "severity": detection.severity.value,
                            "confidence": confidence,
                            "file_path": file_path,
                            "file_hash": file_hash,
                            "user_id": user_id,
                            "user_age": user_age,
                        },
                    )

            return detections

        except FileNotFoundError:
            self.logger.error(f"Файл не найден: {file_path}")
            raise
        except PermissionError:
            self.logger.error(f"Нет прав доступа к файлу: {file_path}")
            raise
        except ValueError as e:
            self.logger.error(f"Некорректные параметры: {e}")
            raise
        except OSError as e:
            self.logger.error(
                f"Ошибка файловой системы при сканировании {file_path}: {e}"
            )
            raise
        except Exception as e:
            self.logger.error(
                f"Неожиданная ошибка при сканировании {file_path}: {e}"
            )
            raise RuntimeError(f"Ошибка сканирования файла: {e}") from e

    async def _calculate_file_hash_async(self, file_path: str) -> str:
        """Асинхронный расчет хеша файла"""

        def _calculate_hash():
            hash_md5 = hashlib.md5()
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()

        # Выполняем в отдельном потоке для неблокирующей работы
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, _calculate_hash)

    async def _calculate_signature_confidence_async(
        self, file_path: str, signature: MalwareSignature, file_hash: str
    ) -> float:
        """Асинхронный расчет уверенности в обнаружении"""

        def _calculate_confidence():
            confidence = 0.0
            # Проверка хеша файла
            if file_hash in signature.file_hashes:
                confidence += 0.8
            # Проверка паттернов в имени файла
            file_name = os.path.basename(file_path).lower()
            for pattern in signature.patterns:
                if pattern.lower() in file_name:
                    confidence += 0.2
            # Проверка паттернов в содержимом файла
            try:
                with open(
                    file_path, "r", encoding="utf-8", errors="ignore"
                ) as f:
                    content = f.read(1024).lower()
                    for pattern in signature.patterns:
                        if pattern.lower() in content:
                            confidence += 0.3
            except Exception:
                pass
            return min(confidence, 1.0)

        # Выполняем в отдельном потоке
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, _calculate_confidence)

    def protect_against_malware(
        self, detection: MalwareDetection
    ) -> List[ProtectionAction]:
        """
        Применение защитных мер против обнаруженного вредоносного ПО.

        Анализирует обнаружение вредоносного ПО и применяет соответствующие
        защитные меры согласно настроенным правилам безопасности.

        Args:
            detection (MalwareDetection): Обнаружение вредоносного ПО для
                обработки. Должно содержать корректную информацию о типе
                угрозы, серьезности и метаданных файла.

        Returns:
            List[ProtectionAction]: Список примененных защитных действий.
                Каждое действие содержит:
                - action_type: Тип действия (QUARANTINE, BLOCK, NOTIFY, etc.)
                - description: Описание выполненного действия
                - timestamp: Время применения действия
                - success: Статус успешности выполнения
                - metadata: Дополнительные метаданные действия

        Raises:
            ValueError: Если detection некорректно или содержит
                недопустимые данные
            TypeError: Если detection не является экземпляром
                MalwareDetection
            RuntimeError: Если не удалось применить защитные меры

        Example:
            >>> mp = MalwareProtectionService()
            >>> detection = MalwareDetection(...)
            >>> actions = mp.protect_against_malware(detection)
            >>> for action in actions:
            ...     print(f"Применено действие: {action.description}")
            ...     print(f"Успешно: {action.success}")

        Note:
            - Действия применяются согласно приоритету правил
            - Статус обнаружения обновляется после применения мер
            - Все действия логируются для аудита безопасности
            - Применение мер может занять время в зависимости от сложности

        See Also:
            - scan_file: Сканирование файлов на угрозы
            - _find_applicable_rules: Поиск применимых правил
            - _apply_protection_action: Применение конкретного действия
        """
        # Валидация входных параметров
        if not isinstance(detection, MalwareDetection):
            raise TypeError(
                "detection должен быть экземпляром MalwareDetection"
            )

        if not detection.detection_id:
            raise ValueError("detection_id не может быть пустым")

        if not detection.malware_type:
            raise ValueError("malware_type должен быть указан")

        if not detection.severity:
            raise ValueError("severity должен быть указан")
        try:
            applied_actions = []
            # Находим подходящие правила
            applicable_rules = self._find_applicable_rules(detection)
            for rule in applicable_rules:
                if self._evaluate_rule_conditions(detection, rule):
                    # Применяем действия правила
                    for action in rule.actions:
                        if self._apply_protection_action(detection, action):
                            applied_actions.append(action)
                    # Обновляем статус обнаружения
                    detection.status = MalwareStatus.QUARANTINED
                    detection.protection_actions.extend(applied_actions)
            # Добавляем событие защиты
            if applied_actions:
                self.add_security_event(
                    event_type="malware_protected",
                    severity=detection.severity.value,
                    description=f"Защита от вредоносного ПО: "
                    f"{detection.description}",
                    source="MalwareProtection",
                    metadata={
                        "detection_id": detection.detection_id,
                        "malware_type": detection.malware_type.value,
                        "severity": detection.severity.value,
                        "applied_actions": [
                            action.value for action in applied_actions
                        ],
                        "file_path": detection.file_path,
                        "user_id": detection.metadata.get("user_id"),
                    },
                )
            return applied_actions
        except Exception as e:
            self.logger.error(f"Ошибка защиты от вредоносного ПО: {e}")
            return []

    def _find_applicable_rules(
        self, detection: MalwareDetection
    ) -> List[ProtectionRule]:
        """Поиск применимых правил"""
        applicable_rules = []
        for rule in self.protection_rules.values():
            if (
                rule.enabled
                and rule.malware_type == detection.malware_type
                and self._compare_severity(
                    detection.severity, rule.severity_threshold
                )
            ):
                applicable_rules.append(rule)
        return applicable_rules

    def _compare_severity(
        self,
        detection_severity: MalwareSeverity,
        rule_threshold: MalwareSeverity,
    ) -> bool:
        """Сравнение серьезности"""
        severity_order = {
            MalwareSeverity.LOW: 1,
            MalwareSeverity.MEDIUM: 2,
            MalwareSeverity.HIGH: 3,
            MalwareSeverity.CRITICAL: 4,
        }
        return (
            severity_order[detection_severity]
            >= severity_order[rule_threshold]
        )

    def _evaluate_rule_conditions(
        self, detection: MalwareDetection, rule: ProtectionRule
    ) -> bool:
        """Оценка условий правила"""
        try:
            conditions = rule.conditions
            # Проверка семейных условий
            if rule.family_specific:
                if (
                    rule.age_group == "child"
                    and detection.metadata.get("user_age", 0) >= 18
                ):
                    return False
                elif (
                    rule.age_group == "elderly"
                    and detection.metadata.get("user_age", 0) < 65
                ):
                    return False
            # Проверка условий защиты
            if (
                "auto_quarantine" in conditions
                and not self.automatic_quarantine
            ):
                return False
            if "immediate_block" in conditions:
                return True  # Немедленная блокировка
            if "auto_remove" in conditions:
                return True  # Автоматическое удаление
            return True
        except Exception as e:
            self.logger.error(f"Ошибка оценки условий правила: {e}")
            return False

    def _apply_protection_action(
        self, detection: MalwareDetection, action: ProtectionAction
    ) -> bool:
        """Применение действия защиты"""
        try:
            if action == ProtectionAction.QUARANTINE:
                self.quarantined_files.add(detection.file_path)
                self.log_activity(
                    f"Файл помещен в карантин: {detection.file_path}"
                )
            elif action == ProtectionAction.DELETE:
                try:
                    os.remove(detection.file_path)
                    self.log_activity(f"Файл удален: {detection.file_path}")
                except Exception as e:
                    self.log_activity(
                        f"Ошибка удаления файла {detection.file_path}: {e}",
                        "error",
                    )
            elif action == ProtectionAction.BLOCK_ACCESS:
                self.blocked_hashes.add(detection.file_hash)
                self.log_activity(
                    f"Заблокирован доступ к файлу: {detection.file_path}"
                )
            elif action == ProtectionAction.ALERT_USER:
                self.log_activity(
                    f"Отправлено уведомление пользователю о "
                    f"вредоносном ПО: {detection.detection_id}"
                )
            elif action == ProtectionAction.ALERT_ADMIN:
                self.log_activity(
                    f"Отправлено уведомление администратору о "
                    f"вредоносном ПО: {detection.detection_id}"
                )
            elif action == ProtectionAction.SCAN_SYSTEM:
                self.log_activity("Запущено полное сканирование системы")
            elif action == ProtectionAction.UPDATE_SIGNATURES:
                self.log_activity("Обновление сигнатур вредоносного ПО")
            elif action == ProtectionAction.ISOLATE_NETWORK:
                self.log_activity(
                    "Изоляция сети для предотвращения распространения"
                )
            return True
        except Exception as e:
            self.logger.error(f"Ошибка применения действия {action}: {e}")
            return False

    def _generate_detection_id(self) -> str:
        """Генерация ID обнаружения"""
        timestamp = str(int(time.time() * 1000))
        random_part = hashlib.md5(timestamp.encode()).hexdigest()[:8]
        return f"malware_{timestamp}_{random_part}"

    def get_malware_summary(
        self, user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Получение сводки по вредоносному ПО"""
        try:
            if user_id:
                # Сводка для конкретного пользователя
                user_detections = [
                    detection
                    for detection in self.malware_detections.values()
                    if detection.metadata.get("user_id") == user_id
                ]
            else:
                # Общая сводка
                user_detections = list(self.malware_detections.values())
            summary = {
                "total_detections": len(user_detections),
                "quarantined_files": len(
                    [
                        d
                        for d in user_detections
                        if d.status == MalwareStatus.QUARANTINED
                    ]
                ),
                "removed_files": len(
                    [
                        d
                        for d in user_detections
                        if d.status == MalwareStatus.REMOVED
                    ]
                ),
                "by_severity": {
                    severity.value: len(
                        [d for d in user_detections if d.severity == severity]
                    )
                    for severity in MalwareSeverity
                },
                "by_type": {
                    malware_type.value: len(
                        [
                            d
                            for d in user_detections
                            if d.malware_type == malware_type
                        ]
                    )
                    for malware_type in MalwareType
                },
                "recent_detections": [
                    {
                        "detection_id": detection.detection_id,
                        "type": detection.malware_type.value,
                        "severity": detection.severity.value,
                        "file_path": detection.file_path,
                        "timestamp": detection.timestamp.isoformat(),
                        "status": detection.status.value,
                    }
                    for detection in sorted(
                        user_detections,
                        key=lambda x: x.timestamp,
                        reverse=True,
                    )[:10]
                ],
            }
            return summary
        except Exception as e:
            self.logger.error(f"Ошибка получения сводки: {e}")
            return {}

    def get_family_protection_status(self) -> Dict[str, Any]:
        """Получение статуса семейной защиты"""
        try:
            status = {
                "family_protection_enabled": self.family_protection_enabled,
                "child_protection_mode": self.child_protection_mode,
                "elderly_protection_mode": self.elderly_protection_mode,
                "real_time_scanning": self.real_time_scanning,
                "automatic_quarantine": self.automatic_quarantine,
                "active_rules": len(
                    [r for r in self.protection_rules.values() if r.enabled]
                ),
                "family_specific_rules": len(
                    [
                        r
                        for r in self.protection_rules.values()
                        if r.family_specific
                    ]
                ),
                "quarantined_files_count": len(self.quarantined_files),
                "blocked_hashes_count": len(self.blocked_hashes),
                "protection_settings": self.family_protection_settings,
                "family_history": {
                    user_id: len(detection_ids)
                    for user_id, detection_ids in (
                        self.family_protection_history.items()
                    )
                },
            }
            return status
        except Exception as e:
            self.logger.error(f"Ошибка получения статуса семейной защиты: {e}")
            return {}

    def get_status(self) -> Dict[str, Any]:
        """Получение статуса сервиса"""
        try:
            return {
                "service_name": self.name,
                "status": self.status.value,
                "malware_signatures": len(self.malware_signatures),
                "protection_rules": len(self.protection_rules),
                "total_detections": len(self.malware_detections),
                "quarantined_files": len(self.quarantined_files),
                "blocked_hashes": len(self.blocked_hashes),
                "family_protection_enabled": self.family_protection_enabled,
                "real_time_scanning": self.real_time_scanning,
                "uptime": (
                    (datetime.now() - self.start_time).total_seconds()
                    if hasattr(self, "start_time") and self.start_time
                    else 0
                ),
            }
        except Exception as e:
            self.logger.error(f"Ошибка получения статуса: {e}")
            return {}

    def get_performance_metrics(self) -> Dict[str, Any]:
        """
        Получение метрик производительности системы.

        Returns:
            Dict[str, Any]: Словарь с метриками производительности:
                - scan_count: Количество выполненных сканирований
                - total_scan_time: Общее время сканирования (секунды)
                - average_scan_time: Среднее время сканирования (секунды)
                - cache_hits: Количество попаданий в кэш
                - cache_misses: Количество промахов кэша
                - cache_hit_ratio: Отношение попаданий к общему
                    количеству запросов
                - detections_found: Количество найденных угроз
                - false_positives: Количество ложных срабатываний
                - detection_rate: Частота обнаружения угроз
        """
        try:
            metrics = self._performance_metrics.copy()

            # Рассчитываем дополнительные метрики
            total_cache_requests = (
                metrics["cache_hits"] + metrics["cache_misses"]
            )
            if total_cache_requests > 0:
                metrics["cache_hit_ratio"] = (
                    metrics["cache_hits"] / total_cache_requests
                )
            else:
                metrics["cache_hit_ratio"] = 0.0

            if metrics["scan_count"] > 0:
                metrics["average_scan_time"] = (
                    metrics["total_scan_time"] / metrics["scan_count"]
                )
                metrics["detection_rate"] = (
                    metrics["detections_found"] / metrics["scan_count"]
                )
            else:
                metrics["average_scan_time"] = 0.0
                metrics["detection_rate"] = 0.0

            # Добавляем информацию о кэше
            metrics["cache_size"] = len(self._file_hash_cache)
            metrics["signature_cache_size"] = len(self._signature_cache)

            return metrics

        except Exception as e:
            self.logger.error(f"Ошибка получения метрик: {e}")
            return {}

    def clear_cache(self) -> bool:
        """
        Очистка всех кэшей системы.

        Returns:
            bool: True если кэш успешно очищен, False в случае ошибки
        """
        try:
            # Очищаем кэши
            self._file_hash_cache.clear()
            self._signature_cache.clear()

            # Очищаем кэш LRU
            self._calculate_file_hash.cache_clear()

            self.logger.info("Кэш системы очищен")
            return True

        except Exception as e:
            self.logger.error(f"Ошибка очистки кэша: {e}")
            return False

    def update_config(self, new_config: Dict[str, Any]) -> bool:
        """
        Обновление конфигурации системы.

        Args:
            new_config (Dict[str, Any]): Новые настройки конфигурации

        Returns:
            bool: True если конфигурация успешно обновлена
        """
        try:
            # Обновляем настройки
            if "max_file_size" in new_config:
                self.max_file_size = new_config["max_file_size"]

            if "cache_ttl" in new_config:
                self.cache_ttl = new_config["cache_ttl"]

            if "scan_timeout" in new_config:
                self.scan_timeout = new_config["scan_timeout"]

            if "enable_async" in new_config:
                self.enable_async = new_config["enable_async"]

            # Обновляем пороги защиты
            if "protection_thresholds" in new_config:
                self.protection_thresholds.update(
                    new_config["protection_thresholds"]
                )

            self.logger.info("Конфигурация системы обновлена")
            return True

        except Exception as e:
            self.logger.error(f"Ошибка обновления конфигурации: {e}")
            return False

    def get_system_health(self) -> Dict[str, Any]:
        """
        Получение информации о состоянии системы.

        Returns:
            Dict[str, Any]: Словарь с информацией о состоянии системы:
                - status: Общий статус системы (healthy/warning/critical)
                - uptime: Время работы системы (секунды)
                - memory_usage: Использование памяти (байты)
                - cache_efficiency: Эффективность кэша (0-1)
                - detection_accuracy: Точность обнаружения (0-1)
                - recommendations: Рекомендации по улучшению
        """
        try:
            metrics = self.get_performance_metrics()

            # Определяем статус системы
            status = "healthy"
            if metrics["cache_hit_ratio"] < 0.5:
                status = "warning"
            if (
                metrics["detection_rate"] > 0.1
            ):  # Более 10% файлов содержат угрозы
                status = "critical"

            # Рассчитываем эффективность кэша
            cache_efficiency = metrics.get("cache_hit_ratio", 0.0)

            # Рассчитываем точность обнаружения
            total_detections = (
                metrics["detections_found"] + metrics["false_positives"]
            )
            if total_detections > 0:
                detection_accuracy = (
                    metrics["detections_found"] / total_detections
                )
            else:
                detection_accuracy = 1.0

            # Генерируем рекомендации
            recommendations = []
            if cache_efficiency < 0.7:
                recommendations.append(
                    "Увеличить размер кэша для улучшения производительности"
                )
            if detection_accuracy < 0.9:
                recommendations.append(
                    "Пересмотреть пороги обнаружения для снижения "
                    "ложных срабатываний"
                )
            if metrics["average_scan_time"] > 5.0:
                recommendations.append("Оптимизировать алгоритмы сканирования")

            return {
                "status": status,
                "uptime": (
                    (datetime.now() - self.start_time).total_seconds()
                    if hasattr(self, "start_time") and self.start_time
                    else 0
                ),
                "memory_usage": len(self._file_hash_cache) * 64
                + len(self._signature_cache) * 32,  # Примерная оценка
                "cache_efficiency": cache_efficiency,
                "detection_accuracy": detection_accuracy,
                "recommendations": recommendations,
                "metrics": metrics,
            }

        except Exception as e:
            self.logger.error(f"Ошибка получения состояния системы: {e}")
            return {"status": "error", "error": str(e)}
